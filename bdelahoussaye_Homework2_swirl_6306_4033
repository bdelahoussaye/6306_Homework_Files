
R version 3.5.0 (2018-04-23) -- "Joy in Playing"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> str(airquality)
'data.frame':   153 obs. of  6 variables:
 $ Ozone  : int  41 36 12 18 NA 28 23 19 8 NA ...
 $ Solar.R: int  190 118 149 313 NA NA 299 99 19 194 ...
 $ Wind   : num  7.4 8 12.6 11.5 14.3 14.9 8.6 13.8 20.1 8.6 ...
 $ Temp   : int  67 72 74 62 56 66 65 59 61 69 ...
 $ Month  : int  5 5 5 5 5 5 5 5 5 5 ...
 $ Day    : int  1 2 3 4 5 6 7 8 9 10 ...
> list(airquality)
[[1]]
    Ozone Solar.R Wind Temp Month Day
1      41     190  7.4   67     5   1
2      36     118  8.0   72     5   2
3      12     149 12.6   74     5   3
4      18     313 11.5   62     5   4
5      NA      NA 14.3   56     5   5
6      28      NA 14.9   66     5   6
7      23     299  8.6   65     5   7
8      19      99 13.8   59     5   8
9       8      19 20.1   61     5   9
10     NA     194  8.6   69     5  10
11      7      NA  6.9   74     5  11
12     16     256  9.7   69     5  12
13     11     290  9.2   66     5  13
14     14     274 10.9   68     5  14
15     18      65 13.2   58     5  15
16     14     334 11.5   64     5  16
17     34     307 12.0   66     5  17
18      6      78 18.4   57     5  18
19     30     322 11.5   68     5  19
20     11      44  9.7   62     5  20
21      1       8  9.7   59     5  21
22     11     320 16.6   73     5  22
23      4      25  9.7   61     5  23
24     32      92 12.0   61     5  24
25     NA      66 16.6   57     5  25
26     NA     266 14.9   58     5  26
27     NA      NA  8.0   57     5  27
28     23      13 12.0   67     5  28
29     45     252 14.9   81     5  29
30    115     223  5.7   79     5  30
31     37     279  7.4   76     5  31
32     NA     286  8.6   78     6   1
33     NA     287  9.7   74     6   2
34     NA     242 16.1   67     6   3
35     NA     186  9.2   84     6   4
36     NA     220  8.6   85     6   5
37     NA     264 14.3   79     6   6
38     29     127  9.7   82     6   7
39     NA     273  6.9   87     6   8
40     71     291 13.8   90     6   9
41     39     323 11.5   87     6  10
42     NA     259 10.9   93     6  11
43     NA     250  9.2   92     6  12
44     23     148  8.0   82     6  13
45     NA     332 13.8   80     6  14
46     NA     322 11.5   79     6  15
47     21     191 14.9   77     6  16
48     37     284 20.7   72     6  17
49     20      37  9.2   65     6  18
50     12     120 11.5   73     6  19
51     13     137 10.3   76     6  20
52     NA     150  6.3   77     6  21
53     NA      59  1.7   76     6  22
54     NA      91  4.6   76     6  23
55     NA     250  6.3   76     6  24
56     NA     135  8.0   75     6  25
57     NA     127  8.0   78     6  26
58     NA      47 10.3   73     6  27
59     NA      98 11.5   80     6  28
60     NA      31 14.9   77     6  29
61     NA     138  8.0   83     6  30
62    135     269  4.1   84     7   1
63     49     248  9.2   85     7   2
64     32     236  9.2   81     7   3
65     NA     101 10.9   84     7   4
66     64     175  4.6   83     7   5
67     40     314 10.9   83     7   6
68     77     276  5.1   88     7   7
69     97     267  6.3   92     7   8
70     97     272  5.7   92     7   9
71     85     175  7.4   89     7  10
72     NA     139  8.6   82     7  11
73     10     264 14.3   73     7  12
74     27     175 14.9   81     7  13
75     NA     291 14.9   91     7  14
76      7      48 14.3   80     7  15
77     48     260  6.9   81     7  16
78     35     274 10.3   82     7  17
79     61     285  6.3   84     7  18
80     79     187  5.1   87     7  19
81     63     220 11.5   85     7  20
82     16       7  6.9   74     7  21
83     NA     258  9.7   81     7  22
84     NA     295 11.5   82     7  23
85     80     294  8.6   86     7  24
86    108     223  8.0   85     7  25
87     20      81  8.6   82     7  26
88     52      82 12.0   86     7  27
89     82     213  7.4   88     7  28
90     50     275  7.4   86     7  29
91     64     253  7.4   83     7  30
92     59     254  9.2   81     7  31
93     39      83  6.9   81     8   1
94      9      24 13.8   81     8   2
95     16      77  7.4   82     8   3
96     78      NA  6.9   86     8   4
97     35      NA  7.4   85     8   5
98     66      NA  4.6   87     8   6
99    122     255  4.0   89     8   7
100    89     229 10.3   90     8   8
101   110     207  8.0   90     8   9
102    NA     222  8.6   92     8  10
103    NA     137 11.5   86     8  11
104    44     192 11.5   86     8  12
105    28     273 11.5   82     8  13
106    65     157  9.7   80     8  14
107    NA      64 11.5   79     8  15
108    22      71 10.3   77     8  16
109    59      51  6.3   79     8  17
110    23     115  7.4   76     8  18
111    31     244 10.9   78     8  19
112    44     190 10.3   78     8  20
113    21     259 15.5   77     8  21
114     9      36 14.3   72     8  22
115    NA     255 12.6   75     8  23
116    45     212  9.7   79     8  24
117   168     238  3.4   81     8  25
118    73     215  8.0   86     8  26
119    NA     153  5.7   88     8  27
120    76     203  9.7   97     8  28
121   118     225  2.3   94     8  29
122    84     237  6.3   96     8  30
123    85     188  6.3   94     8  31
124    96     167  6.9   91     9   1
125    78     197  5.1   92     9   2
126    73     183  2.8   93     9   3
127    91     189  4.6   93     9   4
128    47      95  7.4   87     9   5
129    32      92 15.5   84     9   6
130    20     252 10.9   80     9   7
131    23     220 10.3   78     9   8
132    21     230 10.9   75     9   9
133    24     259  9.7   73     9  10
134    44     236 14.9   81     9  11
135    21     259 15.5   76     9  12
136    28     238  6.3   77     9  13
137     9      24 10.9   71     9  14
138    13     112 11.5   71     9  15
139    46     237  6.9   78     9  16
140    18     224 13.8   67     9  17
141    13      27 10.3   76     9  18
142    24     238 10.3   68     9  19
143    16     201  8.0   82     9  20
144    13     238 12.6   64     9  21
145    23      14  9.2   71     9  22
146    36     139 10.3   81     9  23
147     7      49 10.3   69     9  24
148    14      20 16.6   63     9  25
149    30     193  6.9   70     9  26
150    NA     145 13.2   77     9  27
151    14     191 14.3   75     9  28
152    18     131  8.0   76     9  29
153    20     223 11.5   68     9  30

> swirl()
Error in swirl() : could not find function "swirl"
> library(swirl)

| Hi! I see that you have some variables saved in your workspace. To keep
| things running smoothly, I recommend you clean up before starting swirl.

| Type ls() to see a list of the variables in your workspace. Then, type
| rm(list=ls()) to clear your workspace.

| Type swirl() when you are ready to begin.

> swirl()

| Welcome to swirl! Please sign in. If you've been here before, use the same
| name as you did then. If you are new, call yourself something unique.

What shall I call you? Brandon

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files     
 3: Sequences of Numbers       4: Vectors                 
 5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                   
 9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times         
15: Base Graphics             

Selection: 8

  |                                                                              |                                                                      |   0%

| This lesson is meant to be a short introduction to logical operations in R.

...

  |                                                                              |=                                                                     |   2%
| There are two logical values in R, also called boolean values. They are TRUE and FALSE. In R you can construct logical expressions which will evaluate to either TRUE or FALSE.

...

  |                                                                              |===                                                                   |   4%
| Many of the questions in this lesson will involve evaluating logical expressions. It may be useful to open up a second R terminal where you can experiment with some of these
| expressions.

...

  |                                                                              |====                                                                  |   6%
| Creating logical expressions requires logical operators. You're probably familiar with arithmetic operators like `+`, `-`, `*`, and `/`. The first logical operator we are going to
| discuss is the equality operator, represented by two equals signs `==`. Use the equality operator below to find out if TRUE is equal to TRUE.

> true=true
Error: object 'true' not found
> true == true
Error: object 'true' not found
> "True" == "true"
[1] FALSE

| You almost had it, but not quite. Try again. Or, type info() for more options.

| Use the equality operator and type TRUE == TRUE

> TRUE == TRUE
[1] TRUE

| All that practice is paying off!

  |                                                                              |=====                                                                 |   8%
| Just like arithmetic, logical expressions can be grouped by parenthesis so that the entire expression (TRUE == TRUE) == TRUE evaluates to TRUE.

...

  |                                                                              |=======                                                               |  10%
| To test out this property, try evaluating (FALSE == TRUE) == FALSE .

> (FALSE == TRUE) == FALSE
[1] TRUE

| Your dedication is inspiring!

  |                                                                              |========                                                              |  12%
| The equality operator can also be used to compare numbers. Use `==` to see if 6 is equal to 7.

> 6==7
[1] FALSE

| You are amazing!

  |                                                                              |=========                                                             |  13%
| The previous expression evaluates to FALSE because 6 is less than 7. Thankfully, there are inequality operators that allow us to test if a value is less than or greater than another
| value.

...

  |                                                                              |===========                                                           |  15%
| The less than operator `<` tests whether the number on the left side of the operator (called the left operand) is less than the number on the right side of the operator (called the
| right operand). Write an expression to test whether 6 is less than 7.

> 6<7
[1] TRUE

| All that practice is paying off!

  |                                                                              |============                                                          |  17%
| There is also a less-than-or-equal-to operator `<=` which tests whether the left operand is less than or equal to the right operand. Write an expression to test whether 10 is less than
| or equal to 10.

> 10 <=10
[1] TRUE

| You got it right!

  |                                                                              |=============                                                         |  19%
| Keep in mind that there are the corresponding greater than `>` and greater-than-or-equal-to `>=` operators.

...

  |                                                                              |===============                                                       |  21%
| Which of the following evaluates to FALSE?

1: 0 > -36
2: 6 < 8
3: 9 >= 10
4: 7 == 7

Selection: 3

| Nice work!

  |                                                                              |================                                                      |  23%
| Which of the following evaluates to TRUE?

1: 7 == 9
2: 9 >= 10
3: 57 < 8
4: -6 > -7

Selection: 4

| Nice work!

  |                                                                              |==================                                                    |  25%
| The next operator we will discuss is the 'not equals' operator represented by `!=`. Not equals tests whether two values are unequal, so TRUE != FALSE evaluates to TRUE. Like the
| equality operator, `!=` can also be used with numbers. Try writing an expression to see if 5 is not equal to 7.

> 5!=7
[1] TRUE

| You are quite good my friend!

  |                                                                              |===================                                                   |  27%
| In order to negate boolean expressions you can use the NOT operator. An exclamation point `!` will cause !TRUE (say: not true) to evaluate to FALSE and !FALSE (say: not false) to
| evaluate to TRUE. Try using the NOT operator and the equals operator to find the opposite of whether 5 is equal to 7.

> 5!7
Error: unexpected '!' in "5!"
> 5 ! 7
Error: unexpected '!' in "5 !"
> skip()

| Entering the following correct answer for you...

> !5 == 7
[1] TRUE

| Your dedication is inspiring!

  |                                                                              |====================                                                  |  29%
| Let's take a moment to review. The equals operator `==` tests whether two boolean values or numbers are equal, the not equals operator `!=` tests whether two boolean values or numbers
| are unequal, and the NOT operator `!` negates logical expressions so that TRUE expressions become FALSE and FALSE expressions become TRUE.

...

  |                                                                              |======================                                                |  31%
| Which of the following evaluates to FALSE?

1: !FALSE
2: !(0 >= -1)
3: 9 < 10
4: 7 != 8

Selection: 4

| Not quite, but you're learning! Try again.

| If you need to, you can evaluate each expression in a separate R session to find the correct answer.

1: !(0 >= -1)
2: !FALSE
3: 7 != 8
4: 9 < 10

Selection: 1

| All that practice is paying off!

  |                                                                              |=======================                                               |  33%
| What do you think the following expression will evaluate to?: (TRUE != FALSE) == !(6 == 7)

1: %>%
2: FALSE
3: Can there be objective truth when programming?
4: TRUE

Selection: 4

| Your dedication is inspiring!

  |                                                                              |========================                                              |  35%
| At some point you may need to examine relationships between multiple logical expressions. This is where the AND operator and the OR operator come in.

...

  |                                                                              |==========================                                            |  37%
| Let's look at how the AND operator works. There are two AND operators in R, `&` and `&&`. Both operators work similarly, if the right and left operands of AND are both TRUE the entire
| expression is TRUE, otherwise it is FALSE. For example, TRUE & TRUE evaluates to TRUE. Try typing FALSE & FALSE to how it is evaluated.

> FALSE & FALSE
[1] FALSE

| You nailed it! Good job!

  |                                                                              |===========================                                           |  38%
| You can use the `&` operator to evaluate AND across a vector. The `&&` version of AND only evaluates the first member of a vector. Let's test both for practice. Type the expression TRUE
| & c(TRUE, FALSE, FALSE).

> TRUE & c(TRUE, FALSE, FALSE)
[1]  TRUE FALSE FALSE

| Excellent job!

  |                                                                              |============================                                          |  40%
| What happens in this case is that the left operand `TRUE` is recycled across every element in the vector of the right operand. This is the equivalent statement as c(TRUE, TRUE, TRUE) &
| c(TRUE, FALSE, FALSE).

...

  |                                                                              |==============================                                        |  42%
| Now we'll type the same expression except we'll use the `&&` operator. Type the expression TRUE && c(TRUE, FALSE, FALSE).

> TRUE && c(TRUE, FALSE, FALSE)
[1] TRUE

| Great job!

  |                                                                              |===============================                                       |  44%
| In this case, the left operand is only evaluated with the first member of the right operand (the vector). The rest of the elements in the vector aren't evaluated at all in this
| expression.

...

  |                                                                              |================================                                      |  46%
| The OR operator follows a similar set of rules. The `|` version of OR evaluates OR across an entire vector, while the `||` version of OR only evaluates the first member of a vector.

...

  |                                                                              |==================================                                    |  48%
| An expression using the OR operator will evaluate to TRUE if the left operand or the right operand is TRUE. If both are TRUE, the expression will evaluate to TRUE, however if neither
| are TRUE, then the expression will be FALSE.

...

  |                                                                              |===================================                                   |  50%
| Let's test out the vectorized version of the OR operator. Type the expression TRUE | c(TRUE, FALSE, FALSE).

> True|c(TRUE, FALSE, FALSE)
Error: object 'True' not found
> TRUE | c(TRUE, FALSE, FALSE)
[1] TRUE TRUE TRUE

| Perseverance, that's the answer.

  |                                                                              |====================================                                  |  52%
| Now let's try out the non-vectorized version of the OR operator. Type the expression TRUE || c(TRUE, FALSE, FALSE).

> TRUE || c(TRUE, FALSE, FALSE)
[1] TRUE

| You nailed it! Good job!

  |                                                                              |======================================                                |  54%
| Logical operators can be chained together just like arithmetic operators. The expressions: `6 != 10 && FALSE && 1 >= 2` or `TRUE || 5 < 9.3 || FALSE` are perfectly normal to see.

...

  |                                                                              |=======================================                               |  56%
| As you may recall, arithmetic has an order of operations and so do logical expressions. All AND operators are evaluated before OR operators. Let's look at an example of an ambiguous
| case. Type: 5 > 8 || 6 != 8 && 4 > 3.9

> 5 > 8 || 6 != 8 && 4>3.9
[1] TRUE

| Perseverance, that's the answer.

  |                                                                              |========================================                              |  58%
| Let's walk through the order of operations in the above case. First the left and right operands of the AND operator are evaluated. 6 is not equal 8, 4 is greater than 3.9, therefore
| both operands are TRUE so the resulting expression `TRUE && TRUE` evaluates to TRUE. Then the left operand of the OR operator is evaluated: 5 is not greater than 8 so the entire
| expression is reduced to FALSE || TRUE. Since the right operand of this expression is TRUE the entire expression evaluates to TRUE.

...

  |                                                                              |==========================================                            |  60%
| Which one of the following expressions evaluates to TRUE?

1: TRUE && FALSE || 9 >= 4 && 3 < 6
2: TRUE && 62 < 62 && 44 >= 44
3: 99.99 > 100 || 45 < 7.3 || 4 != 4.0
4: FALSE || TRUE && FALSE

Selection: 1

| All that practice is paying off!

  |                                                                              |===========================================                           |  62%
| Which one of the following expressions evaluates to FALSE?

1: FALSE || TRUE && 6 != 4 || 9 > 4
2: 6 >= -9 && !(6 > 7) && !(!TRUE)
3: FALSE && 6 >= 6 || 7 >= 8 || 50 <= 49.5
4: !(8 > 4) ||  5 == 5.0 && 7.8 >= 7.79

Selection: 2

| You almost had it, but not quite. Try again.

| Try to evaluate each expression in isolation and build up an answer.

1: FALSE || TRUE && 6 != 4 || 9 > 4
2: FALSE && 6 >= 6 || 7 >= 8 || 50 <= 49.5
3: 6 >= -9 && !(6 > 7) && !(!TRUE)
4: !(8 > 4) ||  5 == 5.0 && 7.8 >= 7.79

Selection: 2

| Excellent job!

  |                                                                              |============================================                          |  63%
| Now that you're familiar with R's logical operators you can take advantage of a few functions that R provides for dealing with logical expressions.

...

  |                                                                              |==============================================                        |  65%
| The function isTRUE() takes one argument. If that argument evaluates to TRUE, the function will return TRUE. Otherwise, the function will return FALSE. Try using this function by
| typing: isTRUE(6 > 4)

> isTRUE(6>4)
[1] TRUE

| You are really on a roll!

  |                                                                              |===============================================                       |  67%
| Which of the following evaluates to TRUE?

1: isTRUE(!TRUE)
2: !isTRUE(8 != 5)
3: isTRUE(3)
4: !isTRUE(4 < 3)
5: isTRUE(NA)

Selection: 2

| Not exactly. Give it another go.

| isTRUE() will only return TRUE if the statement passed to it as an argument is TRUE.

1: isTRUE(!TRUE)
2: isTRUE(3)
3: isTRUE(NA)
4: !isTRUE(8 != 5)
5: !isTRUE(4 < 3)

Selection: 5

| You are amazing!

  |                                                                              |================================================                      |  69%
| The function identical() will return TRUE if the two R objects passed to it as arguments are identical. Try out the identical() function by typing: identical('twins', 'twins')

> identical('twins', 'twins')
[1] TRUE

| All that practice is paying off!

  |                                                                              |==================================================                    |  71%
| Which of the following evaluates to TRUE?

1: identical(4, 3.1)
2: !identical(7, 7)
3: identical(5 > 4, 3 < 3.1)
4: identical('hello', 'Hello')

Selection: 3

| You are really on a roll!

  |                                                                              |===================================================                   |  73%
| You should also be aware of the xor() function, which takes two arguments. The xor() function stands for exclusive OR. If one argument evaluates to TRUE and one argument evaluates to
| FALSE, then this function will return TRUE, otherwise it will return FALSE. Try out the xor() function by typing: xor(5 == 6, !FALSE)

> xor(5++6, !FALSE)
[1] FALSE

| One more time. You can do it! Or, type info() for more options.

| Test out the xor() function by typing: xor(5 == 6, !FALSE)

> xor(5==6, ! FALSE)
[1] TRUE

| That's the answer I was looking for.

  |                                                                              |====================================================                  |  75%
| 5 == 6 evaluates to FALSE, !FALSE evaluates to TRUE, so xor(FALSE, TRUE) evaluates to TRUE. On the other hand if the first argument was changed to 5 == 5 and the second argument was
| unchanged then both arguments would have been TRUE, so xor(TRUE, TRUE) would have evaluated to FALSE.

...

  |                                                                              |======================================================                |  77%
| Which of the following evaluates to FALSE?

1: xor(!isTRUE(TRUE), 6 > -1)
2: xor(4 >= 9, 8 != 8.0)
3: xor(identical(xor, 'xor'), 7 == 7.0)
4: xor(!!TRUE, !!FALSE)

Selection: 2

| All that practice is paying off!

  |                                                                              |=======================================================               |  79%
| For the next few questions, we're going to need to create a vector of integers called ints. Create this vector by typing: ints <- sample(10)

> ints <- sample(10)

| Keep up the great work!

  |                                                                              |=========================================================             |  81%
| Now simply display the contents of ints.

> print(ints)
 [1]  8 10  4  3  7  6  9  5  2  1

| Not exactly. Give it another go. Or, type info() for more options.

| To view the vector type: ints

> ints
 [1]  8 10  4  3  7  6  9  5  2  1

| Keep up the great work!

  |                                                                              |==========================================================            |  83%
| The vector `ints` is a random sampling of integers from 1 to 10 without replacement. Let's say we wanted to ask some logical questions about contents of ints. If we type ints > 5, we
| will get a logical vector corresponding to whether each element of ints is greater than 5. Try typing: ints > 5

> ints >5
 [1]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE

| That's a job well done!

  |                                                                              |===========================================================           |  85%
| We can use the resulting logical vector to ask other questions about ints. The which() function takes a logical vector as an argument and returns the indices of the vector that are
| TRUE. For example which(c(TRUE, FALSE, TRUE)) would return the vector c(1, 3).

...

  |                                                                              |=============================================================         |  87%
| Use the which() function to find the indices of ints that are greater than 7.

> which(ints >7)
[1] 1 2 7

| You are doing so well!

  |                                                                              |==============================================================        |  88%
| Which of the following commands would produce the indices of the elements in ints that are less than or equal to 2?

1: which(ints < 2)
2: which(ints <= 2)
3: ints <= 2
4: ints < 2

Selection: 2

| You got it!

  |                                                                              |===============================================================       |  90%
| Like the which() function, the functions any() and all() take logical vectors as their argument. The any() function will return TRUE if one or more of the elements in the logical vector
| is TRUE. The all() function will return TRUE if every element in the logical vector is TRUE.

...

  |                                                                              |=================================================================     |  92%
| Use the any() function to see if any of the elements of ints are less than zero.

> any(ints)
[1] TRUE

| Nice try, but that's not exactly what I was hoping for. Try again. Or, type info() for more options.

| Use the any() function on the logical vector produced by: `ints < 0`

> any(ints)
[1] TRUE

| Not quite, but you're learning! Try again. Or, type info() for more options.

| Use the any() function on the logical vector produced by: `ints < 0`

> any(ints<0)
[1] FALSE

| You nailed it! Good job!

  |                                                                              |==================================================================    |  94%
| Use the all() function to see if all of the elements of ints are greater than zero.

> all(ints>0)
[1] TRUE

| Excellent work!

  |                                                                              |===================================================================   |  96%
| Which of the following evaluates to TRUE?

1: all(c(TRUE, FALSE, TRUE))
2: any(ints == 10)
3: all(ints == 10)
4: any(ints == 2.5)

Selection: 3

| Try again. Getting it right on the first try is boring anyway!

| any() will evaluate to TRUE if there is one or more TRUE elements in a logical vector.

1: all(ints == 10)
2: any(ints == 2.5)
3: any(ints == 10)
4: all(c(TRUE, FALSE, TRUE))

Selection: 4

| One more time. You can do it!

| any() will evaluate to TRUE if there is one or more TRUE elements in a logical vector.

1: any(ints == 2.5)
2: any(ints == 10)
3: all(c(TRUE, FALSE, TRUE))
4: all(ints == 10)

Selection: 2

| That's the answer I was looking for.

  |                                                                              |===================================================================== |  98%
| That's all for this introduction to logic in R. If you really want to see what you can do with logic, check out the control flow lesson!

...

  |                                                                              |======================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: Yes
2: No

Selection: 2

| Nice work!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply         11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times           15: Base Graphics             

Selection: 9

  |                                                                                                                                                                                          |                                                                                                                                                                                  |   0%

| Functions are one of the fundamental building blocks of the R language. They are small pieces of reusable code that can be treated like any other R object.

...

  |                                                                                                                                                                                          |====                                                                                                                                                                              |   2%
| If you've worked through any other part of this course, you've probably used some functions already. Functions are usually characterized by the name of the function followed by
| parentheses.

...

  |                                                                                                                                                                                          |=======                                                                                                                                                                           |   4%
| Let's try using a few basic functions just for fun. The Sys.Date() function returns a string representing today's date. Type Sys.Date() below and see what happens.

> sys.date()
Error in sys.date() : could not find function "sys.date"
> Sys.Date()
[1] "2018-05-17"

| You are doing so well!

  |                                                                                                                                                                                          |===========                                                                                                                                                                       |   6%
| Most functions in R return a value. Functions like Sys.Date() return a value based on your computer's environment, while other functions manipulate input data in order to compute a
| return value.

...

  |                                                                                                                                                                                          |===============                                                                                                                                                                   |   8%
| The mean() function takes a vector of numbers as input, and returns the average of all of the numbers in the input vector. Inputs to functions are often called arguments. Providing
| arguments to a function is also sometimes called passing arguments to that function. Arguments you want to pass to a function go inside the function's parentheses. Try passing the
| argument c(2, 4, 5) to the mean() function.

> mean(c(2,4,5))
[1] 3.666667

| Your dedication is inspiring!

  |                                                                                                                                                                                          |==================                                                                                                                                                                |  10%
| Functions usually take arguments which are variables that the function operates on. For example, the mean() function takes a vector as an argument, like in the case of mean(c(2,6,8)).
| The mean() function then adds up all of the numbers in the vector and divides that sum by the length of the vector.

...

  |                                                                                                                                                                                          |======================                                                                                                                                                            |  12%
| In the following question you will be asked to modify a script that will appear as soon as you move on from this question. When you have finished modifying the script, save your changes
| to the script and type submit() and the script will be evaluated. There will be some comments in the script that opens up, so be sure to read them!

...

  |                                                                                                                                                                                          |=========================                                                                                                                                                         |  14%
| The last R expression to be evaluated in a function will become the return value of that function. We want this function to take one argument, x, and return x without modifying it.
| Delete the pound sign so that x is returned without any modification. Make sure to save your script before you type submit().

>   x
 [1]          NA          NA -0.86867902          NA          NA -0.23893261
 [7]          NA          NA  0.25109672 -0.27582977  0.34398630          NA
[13]          NA  0.35154977          NA          NA          NA          NA
[19]          NA -0.67859122  0.08877186          NA -0.27815706          NA
[25]          NA -0.99114632          NA -1.62448744 -0.82246287  1.38536080
[31] -0.31329923  0.23056499          NA          NA -0.14378969 -1.23546524
[37]  0.14058996  0.58282334          NA -1.60875462
> 
> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...

| Perseverance, that's the answer.

  |                                                                                                                                                                                          |=============================                                                                                                                                                     |  16%
| Now that you've created your first function let's test it! Type: boring_function('My first function!'). If your function works, it should just return the string: 'My first function!'

> boring_function('My first function!')
[1] "My first function!"

| Excellent work!

  |                                                                                                                                                                                          |=================================                                                                                                                                                 |  18%
| Congratulations on writing your first function. By writing functions, you can gain serious insight into how R works. As John Chambers, the creator of R once said:
| 
| To understand computations in R, two slogans are helpful: 1. Everything that exists is an object. 2. Everything that happens is a function call.

...

  |                                                                                                                                                                                          |====================================                                                                                                                                              |  20%
| If you want to see the source code for any function, just type the function name without any arguments or parentheses. Let's try this out with the function you just created. Type:
| boring_function to view its source code.

> boring_function
function(x) {
  x
}
<bytecode: 0x000000001add5fd0>

| You are doing so well!

  |                                                                                                                                                                                          |========================================                                                                                                                                          |  22%
| Time to make a more useful function! We're going to replicate the functionality of the mean() function by creating a function called: my_mean(). Remember that to calculate the average
| of all of the numbers in a vector you find the sum of all the numbers in the vector, and then divide that sum by the number of numbers in the vector.

...

  |                                                                                                                                                                                          |============================================                                                                                                                                      |  24%
| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| Give it another try.

| Use the sum() function to find the sum of all the numbers in the vector. Use the length() function to find the size of the vector.

> submit
function () 
{
    invisible()
}
<bytecode: 0x000000001ccb84c8>
<environment: namespace:swirl>
> submit()

| Sourcing your script...


| Try again. Getting it right on the first try is boring anyway!

| Use the sum() function to find the sum of all the numbers in the vector. Use the length() function to find the size of the vector.

> my_mean <- function(my_vector) {
+   sum(c(1,5,9,3,4))/length(c(1,5,9,3,4))
+  
+ }
> my_mean <- function(my_vector) {
+   sum(c(1,5,9,3,4))/length(c(1,5,9,3,4))
+  
+ }
> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...my_mean <- function(my_vector) {

| You nailed it! Good job!

  |                                                                                                                                                                                          |===============================================                                                                                                                                   |  27%
| Now test out your my_mean() function by finding the mean of the vector c(4,
| 5, 10).

> my_mean <- function(my_vector) {
+  c(2,5,8,9)  sum(my_vector)/length(my_vector)
Error: unexpected symbol in:
"my_mean <- function(my_vector) {
 c(2,5,8,9)  sum"
> }
Error: unexpected '}' in "}"
> skip()

| Entering the following correct answer for you...

> my_mean(c(4, 5, 10))
[1] 6.333333

| That's the answer I was looking for.

  |                                                                                                                                                                                          |===================================================                                                                                                                               |  29%
| Next, let's try writing a function with default arguments. You can set default values for a function's arguments, and this can be useful if you think someone who uses your function will
| set a certain argument to the same value most of the time.

...

  |                                                                                                                                                                                          |======================================================                                                                                                                            |  31%
| Make sure to save your script before you type submit().

> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...

| Excellent work!

  |                                                                                                                                                                                          |==========================================================                                                                                                                        |  33%
| Let's do some testing of the remainder function. Run remainder(5) and see what happens.

> remainder(5)
[1] 1

| Excellent work!

  |                                                                                                                                                                                          |==============================================================                                                                                                                    |  35%
| Let's take a moment to examine what just happened. You provided one argument to the function, and R matched that argument to 'num' since 'num' is the first argument. The default value
| for 'divisor' is 2, so the function used the default value you provided.

...

  |                                                                                                                                                                                          |=================================================================                                                                                                                 |  37%
| Now let's test the remainder function by providing two arguments. Type: remainder(11, 5) and let's see what happens.

> remainder(11,5)
[1] 1

| You're the best!

  |                                                                                                                                                                                          |=====================================================================                                                                                                             |  39%
| Once again, the arguments have been matched appropriately.

...

  |                                                                                                                                                                                          |=========================================================================                                                                                                         |  41%
| You can also explicitly specify arguments in a function. When you explicitly designate argument values by name, the ordering of the arguments becomes unimportant. You can try this out
| by typing: remainder(divisor = 11, num = 5).

> remainder(divisor = 11, num = 5)
[1] 5

| Great job!

  |                                                                                                                                                                                          |============================================================================                                                                                                      |  43%
| As you can see, there is a significant difference between remainder(11, 5) and remainder(divisor = 11, num = 5)!

...

  |                                                                                                                                                                                          |================================================================================                                                                                                  |  45%
| R can also partially match arguments. Try typing remainder(4, div = 2) to see this feature in action.

> remainder(4, div=2)
[1] 0

| You nailed it! Good job!

  |                                                                                                                                                                                          |====================================================================================                                                                                              |  47%
| A word of warning: in general you want to make your code as easy to understand as possible. Switching around the orders of arguments by specifying their names or only using partial
| argument names can be confusing, so use these features with caution!

...

  |                                                                                                                                                                                          |=======================================================================================                                                                                           |  49%
| With all of this talk about arguments, you may be wondering if there is a way you can see a function's arguments (besides looking at the documentation). Thankfully, you can use the
| args() function! Type: args(remainder) to examine the arguments for the remainder function.

> args(remainder)
function (num, divisor = 2) 
NULL

| You are really on a roll!

  |                                                                                                                                                                                          |===========================================================================================                                                                                       |  51%
| You may not realize it but I just tricked you into doing something pretty interesting! args() is a function, remainder() is a function, yet remainder was an argument for args(). Yes
| it's true: you can pass functions as arguments! This is a very powerful concept. Let's write a script to see how it works.

...

  |                                                                                                                                                                                          |==============================================================================================                                                                                    |  53%
| Make sure to save your script before you type submit().

> evaluate <- function(2,4,6){ sum(2,4,6) 
Error: unexpected numeric constant in "evaluate <- function(2"
> }
Error: unexpected '}' in "}"
> evaluate <- function (7,40,9) {median(7,40,0)
Error: unexpected numeric constant in "evaluate <- function (7"
> }
Error: unexpected '}' in "}"
> evaluate <- function (floor, 11.1) { floor (11.1)
Error: unexpected numeric constant in "evaluate <- function (floor, 11.1"
> }
Error: unexpected '}' in "}"
> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...

| That's a job well done!

  |                                                                                                                                                                                          |==================================================================================================                                                                                |  55%
| Let's take your new evaluate() function for a spin! Use evaluate to find the standard deviation of the vector c(1.4, 3.6, 7.9, 8.8).

> evaluate (c(1.4,3.6,7.9,8.8))
Error in func(dat) : could not find function "func"
> skip()

| Entering the following correct answer for you...

> evaluate(sd, c(1.4, 3.6, 7.9, 8.8))
[1] 3.514138

| You got it right!

  |                                                                                                                                                                                          |======================================================================================================                                                                            |  57%
| The idea of passing functions as arguments to other functions is an important and fundamental concept in programming.

...

  |                                                                                                                                                                                          |=========================================================================================================                                                                         |  59%
| You may be surprised to learn that you can pass a function as an argument without first defining the passed function. Functions that are not named are appropriately known as anonymous
| functions.

...

  |                                                                                                                                                                                          |=============================================================================================================                                                                     |  61%
| Let's use the evaluate function to explore how anonymous functions work. For the first argument of the evaluate function we're going to write a tiny function that fits on one line. In
| the second argument we'll pass some data to the tiny anonymous function in the first argument.

...

  |                                                                                                                                                                                          |=================================================================================================================                                                                 |  63%
| Type the following command and then we'll discuss how it works: evaluate(function(x){x+1}, 6)

> evaluate(function(x)(x+1), 6)
[1] 7

| You got it right!

  |                                                                                                                                                                                          |====================================================================================================================                                                              |  65%
| The first argument is a tiny anonymous function that takes one argument `x` and returns `x+1`. We passed the number 6 into this function so the entire expression evaluates to 7.

...

  |                                                                                                                                                                                          |========================================================================================================================                                                          |  67%
| Try using evaluate() along with an anonymous function to return the first element of the vector c(8, 4, 0). Your anonymous function should only take one argument which should be a
| variable `x`.

> evaluate(function (num1, num2, num3) (num1), 8,4,0)
Error in evaluate(function(num1, num2, num3) (num1), 8, 4, 0) : 
  unused arguments (4, 0)
> skip()

| Entering the following correct answer for you...

> evaluate(function(x){x[1]}, c(8, 4, 0))
[1] 8

| You got it!

  |                                                                                                                                                                                          |============================================================================================================================                                                      |  69%
| Now try using evaluate() along with an anonymous function to return the last element of the vector c(8, 4, 0). Your anonymous function should only take one argument which should be a
| variable `x`.

> evaluate(function(x) {x[3]}, c(8,4,0)
+ }
Error: unexpected '}' in:
"evaluate(function(x) {x[3]}, c(8,4,0)
}"
> skip()

| Entering the following correct answer for you...

> evaluate(function(x){x[length(x)]}, c(8, 4, 0))
[1] 0

| All that hard work is paying off!

  |                                                                                                                                                                                          |===============================================================================================================================                                                   |  71%
| For the rest of the course we're going to use the paste() function frequently. Type ?paste so we can take a look at the documentation for the paste function.

> skip()

| Entering the following correct answer for you...

> ?paste
starting httpd help server ... done

| You are doing so well!

  |                                                                                                                                                                                          |===================================================================================================================================                                               |  73%
| As you can see the first argument of paste() is `...` which is referred to as an ellipsis or simply dot-dot-dot. The ellipsis allows an indefinite number of arguments to be passed into
| a function. In the case of paste() any number of strings can be passed as arguments and paste() will return all of the strings combined into one string.

...

  |                                                                                                                                                                                          |======================================================================================================================================                                            |  76%
| Just to see how paste() works, type paste("Programming", "is", "fun!")

> skip()

| Entering the following correct answer for you...

> paste("Programming", "is", "fun!")
[1] "Programming is fun!"

| Perseverance, that's the answer.

  |                                                                                                                                                                                          |==========================================================================================================================================                                        |  78%
| Time to write our own modified version of paste().

...

  |                                                                                                                                                                                          |==============================================================================================================================================                                    |  80%
| Make sure to save your script before you type submit().

> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...

| That's correct!

  |                                                                                                                                                                                          |=================================================================================================================================================                                 |  82%
| Now let's test out your telegram function. Use your new telegram function passing in whatever arguments you wish!

> skip()

| Entering the following correct answer for you...

> telegram()
[1] "START STOP"

| All that hard work is paying off!

  |                                                                                                                                                                                          |=====================================================================================================================================================                             |  84%
| Make sure to save your script before you type submit().

> 
> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...

| You're the best!

  |                                                                                                                                                                                          |=========================================================================================================================================================                         |  86%
| Time to use your mad_libs function. Make sure to name the place, adjective, and noun arguments in order for your function to work.

> skip()

| Entering the following correct answer for you...

> mad_libs(adjective = "", place = "", noun = "")
[1] "News from  today where  students took to the streets in protest of the new  being installed on campus."

| That's correct!

  |                                                                                                                                                                                          |============================================================================================================================================================                      |  88%
| We're coming to the end of this lesson, but there's still one more idea you should be made aware of.

...

  |                                                                                                                                                                                          |================================================================================================================================================================                  |  90%
| You're familiar with adding, subtracting, multiplying, and dividing numbers in R. To do this you use the +, -, *, and / symbols. These symbols are called binary operators because they
| take two inputs, an input from the left and an input from the right.

...

  |                                                                                                                                                                                          |===================================================================================================================================================================               |  92%
| In R you can define your own binary operators. In the next script I'll show you how.

...

  |                                                                                                                                                                                          |=======================================================================================================================================================================           |  94%
| Make sure to save your script before you type submit().

> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...

| You are doing so well!

  |                                                                                                                                                                                          |===========================================================================================================================================================================       |  96%
| You made your own binary operator! Let's test it out. Paste together the strings: 'I', 'love', 'R!' using your new binary operator.

> skip()

| Entering the following correct answer for you...

> 'I' %p% 'love' %p% 'R!'
[1] "I love R!"

| You got it!

  |                                                                                                                                                                                          |==============================================================================================================================================================================    |  98%
| We've come to the end of our lesson! Go out there and write some great functions!

...

  |                                                                                                                                                                                          |==================================================================================================================================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: No
2: Yes

Selection: 1

| Nice work!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply         11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times           15: Base Graphics             

Selection: 9

  |                                                                                                                                                                                          |                                                                                                                                                                                  |   0%

| Functions are one of the fundamental building blocks of the R language. They are small pieces of reusable code that can be treated like any other R object.

...

  |                                                                                                                                                                                          |====                                                                                                                                                                              |   2%
| If you've worked through any other part of this course, you've probably used some functions already. Functions are usually characterized by the name of the function followed by
| parentheses.

...

  |                                                                                                                                                                                          |=======                                                                                                                                                                           |   4%
| Let's try using a few basic functions just for fun. The Sys.Date() function returns a string representing today's date. Type Sys.Date() below and see what happens.

> sys.date()
Error in sys.date() : could not find function "sys.date"
> Sys.Date()
[1] "2018-05-17"

| You got it!

  |                                                                                                                                                                                          |===========                                                                                                                                                                       |   6%
| Most functions in R return a value. Functions like Sys.Date() return a value based on your computer's environment, while other functions manipulate input data in order to compute a
| return value.

...

  |                                                                                                                                                                                          |===============                                                                                                                                                                   |   8%
| The mean() function takes a vector of numbers as input, and returns the average of all of the numbers in the input vector. Inputs to functions are often called arguments. Providing
| arguments to a function is also sometimes called passing arguments to that function. Arguments you want to pass to a function go inside the function's parentheses. Try passing the
| argument c(2, 4, 5) to the mean() function.

> mean(c(2,4,5))
[1] 3.666667

| Perseverance, that's the answer.

  |                                                                                                                                                                                          |==================                                                                                                                                                                |  10%
| Functions usually take arguments which are variables that the function operates on. For example, the mean() function takes a vector as an argument, like in the case of mean(c(2,6,8)).
| The mean() function then adds up all of the numbers in the vector and divides that sum by the length of the vector.

...

  |                                                                                                                                                                                          |======================                                                                                                                                                            |  12%
| In the following question you will be asked to modify a script that will appear as soon as you move on from this question. When you have finished modifying the script, save your changes
| to the script and type submit() and the script will be evaluated. There will be some comments in the script that opens up, so be sure to read them!

...

  |                                                                                                                                                                                          |=========================                                                                                                                                                         |  14%
| The last R expression to be evaluated in a function will become the return value of that function. We want this function to take one argument, x, and return x without modifying it.
| Delete the pound sign so that x is returned without any modification. Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| Your dedication is inspiring!

  |                                                                                                                                                                                          |=============================                                                                                                                                                     |  16%
| Now that you've created your first function let's test it! Type: boring_function('My first function!'). If your function works, it should just return the string: 'My first function!'

> boring_function('My first function!')
[1] "My first function!"

| Perseverance, that's the answer.

  |                                                                                                                                                                                          |=================================                                                                                                                                                 |  18%
| Congratulations on writing your first function. By writing functions, you can gain serious insight into how R works. As John Chambers, the creator of R once said:
| 
| To understand computations in R, two slogans are helpful: 1. Everything that exists is an object. 2. Everything that happens is a function call.

...

  |                                                                                                                                                                                          |====================================                                                                                                                                              |  20%
| If you want to see the source code for any function, just type the function name without any arguments or parentheses. Let's try this out with the function you just created. Type:
| boring_function to view its source code.

> boring_function
function(x) {
  x
}
<bytecode: 0x000000001b6043a8>

| You are quite good my friend!

  |                                                                                                                                                                                          |========================================                                                                                                                                          |  22%
| Time to make a more useful function! We're going to replicate the functionality of the mean() function by creating a function called: my_mean(). Remember that to calculate the average
| of all of the numbers in a vector you find the sum of all the numbers in the vector, and then divide that sum by the number of numbers in the vector.

...

  |                                                                                                                                                                                          |============================================                                                                                                                                      |  24%
| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| You're close...I can feel it! Try it again.

| Use the sum() function to find the sum of all the numbers in the vector. Use the length() function to find the size of the vector.

> submit()

| Sourcing your script...

Error in source(e$script_temp_path, encoding = "UTF-8") : 
  C:\Users\brndn\AppData\Local\Temp\RtmpAj2POh/my_mean.R:20:24: unexpected '/'
19: 
20: my_mean <- function(sum/
                           ^

| Nice try, but that's not exactly what I was hoping for. Try again.

| Use the sum() function to find the sum of all the numbers in the vector. Use the length() function to find the size of the vector.

> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...

| You are amazing!

  |                                                                                                                                                                                          |===============================================                                                                                                                                   |  27%
| Now test out your my_mean() function by finding the mean of the vector c(4, 5, 10).

> my_mean
function(my_vector) {
  # Write your code here!
  # Remember: the last expression evaluated will be returned! 
  sum(my_vector)/length(my_vector)
}
<bytecode: 0x000000000bf83580>

| That's not the answer I was looking for, but try again. Or, type info() for more options.

| Run the command my_mean(c(4, 5, 10)) to test out your new function.

> my_mean(c(4,5,10))
[1] 6.333333

| Great job!

  |                                                                                                                                                                                          |===================================================                                                                                                                               |  29%
| Next, let's try writing a function with default arguments. You can set default values for a function's arguments, and this can be useful if you think someone who uses your function will
| set a certain argument to the same value most of the time.

...

  |                                                                                                                                                                                          |======================================================                                                                                                                            |  31%
| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| Not quite, but you're learning! Try again.

| Remember to set the appropriate default values!

> submit()

| Sourcing your script...


| That's not exactly what I'm looking for. Try again.

| Remember to set the appropriate default values!

> submit()

| Sourcing your script...


| You're close...I can feel it! Try it again.

| Remember to set the appropriate default values!

> submit()

| Sourcing your script...


| Not quite! Try again.

| Remember to set the appropriate default values!

> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...

| That's the answer I was looking for.

  |                                                                                                                                                                                          |==========================================================                                                                                                                        |  33%
| Let's do some testing of the remainder function. Run remainder(5) and see what happens.

> remainder(5)
[1] 1

| You are doing so well!

  |                                                                                                                                                                                          |==============================================================                                                                                                                    |  35%
| Let's take a moment to examine what just happened. You provided one argument to the function, and R matched that argument to 'num' since 'num' is the first argument. The default value
| for 'divisor' is 2, so the function used the default value you provided.

...

  |                                                                                                                                                                                          |=================================================================                                                                                                                 |  37%
| Now let's test the remainder function by providing two arguments. Type: remainder(11, 5) and let's see what happens.

> remainder (11,5)
[1] 1

| That's correct!

  |                                                                                                                                                                                          |=====================================================================                                                                                                             |  39%
| Once again, the arguments have been matched appropriately.

...

  |                                                                                                                                                                                          |=========================================================================                                                                                                         |  41%
| You can also explicitly specify arguments in a function. When you explicitly designate argument values by name, the ordering of the arguments becomes unimportant. You can try this out
| by typing: remainder(divisor = 11, num = 5).

> remainder(divisor =11,num=5)
[1] 5

| All that hard work is paying off!

  |                                                                                                                                                                                          |============================================================================                                                                                                      |  43%
| As you can see, there is a significant difference between remainder(11, 5) and remainder(divisor = 11, num = 5)!

...

  |                                                                                                                                                                                          |================================================================================                                                                                                  |  45%
| R can also partially match arguments. Try typing remainder(4, div = 2) to see this feature in action.

> remainder(4,div=2)
[1] 0

| Great job!

  |                                                                                                                                                                                          |====================================================================================                                                                                              |  47%
| A word of warning: in general you want to make your code as easy to understand as possible. Switching around the orders of arguments by specifying their names or only using partial
| argument names can be confusing, so use these features with caution!

...

  |                                                                                                                                                                                          |=======================================================================================                                                                                           |  49%
| With all of this talk about arguments, you may be wondering if there is a way you can see a function's arguments (besides looking at the documentation). Thankfully, you can use the
| args() function! Type: args(remainder) to examine the arguments for the remainder function.

> args(remainder)
function (num, divisor = 2) 
NULL

| You're the best!

  |                                                                                                                                                                                          |===========================================================================================                                                                                       |  51%
| You may not realize it but I just tricked you into doing something pretty interesting! args() is a function, remainder() is a function, yet remainder was an argument for args(). Yes
| it's true: you can pass functions as arguments! This is a very powerful concept. Let's write a script to see how it works.

...

  |                                                                                                                                                                                          |==============================================================================================                                                                                    |  53%
| Make sure to save your script before you type submit().

> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...

| You are really on a roll!

  |                                                                                                                                                                                          |==================================================================================================                                                                                |  55%
| Let's take your new evaluate() function for a spin! Use evaluate to find the standard deviation of the vector c(1.4, 3.6, 7.9, 8.8).

> evaluate()
Error in func(dat) : argument "func" is missing, with no default
> evaluate
function(func, dat){
  # Write your code here!
  # Remember: the last expression evaluated will be returned! 
  func(dat)
}
<bytecode: 0x000000000929d9a0>

| Nice try, but that's not exactly what I was hoping for. Try again. Or, type info() for more options.

| The function for standard deviation is called sd(). Make sure that when you pass a function as an argument you pass the name of the function without parentheses!

> evaluate(c(1.4,3.6,7.9,8.8)
+ )
Error in func(dat) : could not find function "func"
> evaluate(sd,c(1.4,3.6,7.9,8.8))
[1] 3.514138

| Great job!

  |                                                                                                                                                                                          |======================================================================================================                                                                            |  57%
| The idea of passing functions as arguments to other functions is an important and fundamental concept in programming.

...

  |                                                                                                                                                                                          |=========================================================================================================                                                                         |  59%
| You may be surprised to learn that you can pass a function as an argument without first defining the passed function. Functions that are not named are appropriately known as anonymous
| functions.

...

  |                                                                                                                                                                                          |=============================================================================================================                                                                     |  61%
| Let's use the evaluate function to explore how anonymous functions work. For the first argument of the evaluate function we're going to write a tiny function that fits on one line. In
| the second argument we'll pass some data to the tiny anonymous function in the first argument.

...

  |                                                                                                                                                                                          |=================================================================================================================                                                                 |  63%
| Type the following command and then we'll discuss how it works: evaluate(function(x){x+1}, 6)

> evaluate(function(x){x+1}, 6)
[1] 7

| All that practice is paying off!

  |                                                                                                                                                                                          |====================================================================================================================                                                              |  65%
| The first argument is a tiny anonymous function that takes one argument `x` and returns `x+1`. We passed the number 6 into this function so the entire expression evaluates to 7.

...

  |                                                                                                                                                                                          |========================================================================================================================                                                          |  67%
| Try using evaluate() along with an anonymous function to return the first element of the vector c(8, 4, 0). Your anonymous function should only take one argument which should be a
| variable `x`.

> evaluate(function(x) {x[1]}, c(8,4,0))
[1] 8

| You are amazing!

  |                                                                                                                                                                                          |============================================================================================================================                                                      |  69%
| Now try using evaluate() along with an anonymous function to return the last element of the vector c(8, 4, 0). Your anonymous function should only take one argument which should be a
| variable `x`.

> evaluate(function(x) {x[3]}, c(8,4,0))
[1] 0

| Not exactly. Give it another go. Or, type info() for more options.

| You may need to recall how to index vector elements. Remember that your anonymous function should only have one argument, and that argument should be named `x`. Using the length()
| function in your anonymous function may help you.

> info()

| When you are at the R prompt (>):
| -- Typing skip() allows you to skip the current question.
| -- Typing play() lets you experiment with R on your own; swirl will ignore what you do...
| -- UNTIL you type nxt() which will regain swirl's attention.
| -- Typing bye() causes swirl to exit. Your progress will be saved.
| -- Typing main() returns you to swirl's main menu.
| -- Typing info() displays these options again.

> help()
> skip()

| Entering the following correct answer for you...

> evaluate(function(x){x[length(x)]}, c(8, 4, 0))
[1] 0

| Keep working like that and you'll get there!

  |                                                                                                                                                                                          |===============================================================================================================================                                                   |  71%
| For the rest of the course we're going to use the paste() function frequently. Type ?paste so we can take a look at the documentation for the paste function.

> ?paste

| You are amazing!

  |                                                                                                                                                                                          |===================================================================================================================================                                               |  73%
| As you can see the first argument of paste() is `...` which is referred to as an ellipsis or simply dot-dot-dot. The ellipsis allows an indefinite number of arguments to be passed into
| a function. In the case of paste() any number of strings can be passed as arguments and paste() will return all of the strings combined into one string.

...

  |                                                                                                                                                                                          |======================================================================================================================================                                            |  76%
| Just to see how paste() works, type paste("Programming", "is", "fun!")

> paste("Programming", "is", "fun!")
[1] "Programming is fun!"

| Excellent job!

  |                                                                                                                                                                                          |==========================================================================================================================================                                        |  78%
| Time to write our own modified version of paste().

...

  |                                                                                                                                                                                          |==============================================================================================================================================                                    |  80%
| Make sure to save your script before you type submit().

> Paste ("START",..., "STOP")
Error in Paste("START", ..., "STOP") : could not find function "Paste"
> submit()

| Sourcing your script...


| One more time. You can do it!

| Remember that arguments can come after ...

> submit()

| Sourcing your script...


| All that practice is paying off!

  |                                                                                                                                                                                          |=================================================================================================================================================                                 |  82%
| Now let's test out your telegram function. Use your new telegram function passing in whatever arguments you wish!

> telegram("Go", "to", "hell", "!
+ ")
[1] "START Go to hell !\n STOP"

| Keep working like that and you'll get there!

  |                                                                                                                                                                                          |=====================================================================================================================================================                             |  84%
| Make sure to save your script before you type submit().

> submith()
Error in submith() : could not find function "submith"
> submit()

| Sourcing your script...


| Not quite! Try again.

| Your function should have three sections: capture the ellipsis in a list(), unpack the arguments from the ellipsis and assign them to variables, then pass those variables to paste().

> submit()

| Sourcing your script...


| You're close...I can feel it! Try it again.

| Your function should have three sections: capture the ellipsis in a list(), unpack the arguments from the ellipsis and assign them to variables, then pass those variables to paste().

> submit()

| Sourcing your script...


| Give it another try.

| Your function should have three sections: capture the ellipsis in a list(), unpack the arguments from the ellipsis and assign them to variables, then pass those variables to paste().

> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...

| Keep working like that and you'll get there!

  |                                                                                                                                                                                          |=========================================================================================================================================================                         |  86%
| Time to use your mad_libs function. Make sure to name the place, adjective, and noun arguments in order for your function to work.

> mad_libs(c(home,sad,sink))
Error in mad_libs(c(home, sad, sink)) : object 'home' not found
> mad_libs(home,sad,sink)
Error in mad_libs(home, sad, sink) : object 'home' not found
> skip()

| Entering the following correct answer for you...

> mad_libs(adjective = "", place = "", noun = "")
[1] "News from  today where  students took to the streets in protest of the new  being installed on campus."

| You are doing so well!

  |                                                                                                                                                                                          |============================================================================================================================================================                      |  88%
| We're coming to the end of this lesson, but there's still one more idea you should be made aware of.

...

  |                                                                                                                                                                                          |================================================================================================================================================================                  |  90%
| You're familiar with adding, subtracting, multiplying, and dividing numbers in R. To do this you use the +, -, *, and / symbols. These symbols are called binary operators because they
| take two inputs, an input from the left and an input from the right.

...

  |                                                                                                                                                                                          |===================================================================================================================================================================               |  92%
| In R you can define your own binary operators. In the next script I'll show you how.

...

  |                                                                                                                                                                                          |=======================================================================================================================================================================           |  94%
| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| That's not exactly what I'm looking for. Try again.

| Remember: 'Hello' %p% 'student!' is how you use the binary operator.

> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...

| You are quite good my friend!

  |                                                                                                                                                                                          |===========================================================================================================================================================================       |  96%
| You made your own binary operator! Let's test it out. Paste together the strings: 'I', 'love', 'R!' using your new binary operator.

> %p%("I","love","R")
Error: unexpected SPECIAL in "%p%"
> skip()

| Entering the following correct answer for you...

> 'I' %p% 'love' %p% 'R!'
[1] "I love R!"

| Nice work!

  |                                                                                                                                                                                          |==============================================================================================================================================================================    |  98%
| We've come to the end of our lesson! Go out there and write some great functions!

...

  |                                                                                                                                                                                          |==================================================================================================================================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: Yes
2: No

Selection: 2

| That's correct!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply         11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times           15: Base Graphics             

Selection: 10

  |                                                                                                                                                                                          |                                                                                                                                                                                  |   0%

| In this lesson, you'll learn how to use lapply() and sapply(), the two most important members of R's *apply family of functions, also known as loop functions.

...

  |                                                                                                                                                                                          |====                                                                                                                                                                              |   2%
| These powerful functions, along with their close relatives (vapply() and tapply(), among others) offer a concise and convenient means of implementing the Split-Apply-Combine strategy
| for data analysis.

...

  |                                                                                                                                                                                          |=======                                                                                                                                                                           |   4%
| Each of the *apply functions will SPLIT up some data into smaller pieces, APPLY a function to each piece, then COMBINE the results. A more detailed discussion of this strategy is found
| in Hadley Wickham's Journal of Statistical Software paper titled 'The Split-Apply-Combine Strategy for Data Analysis'.

...

  |                                                                                                                                                                                          |===========                                                                                                                                                                       |   6%
| Throughout this lesson, we'll use the Flags dataset from the UCI Machine Learning Repository. This dataset contains details of various nations and their flags. More information may be
| found here: http://archive.ics.uci.edu/ml/datasets/Flags

...

  |                                                                                                                                                                                          |==============                                                                                                                                                                    |   8%
| Let's jump right in so you can get a feel for how these special functions work!

...

  |                                                                                                                                                                                          |==================                                                                                                                                                                |  10%
| I've stored the dataset in a variable called flags. Type head(flags) to preview the first six lines (i.e. the 'head') of the dataset.

> head(flags)
            name landmass zone area population language religion bars stripes colours red green blue gold white black orange mainhue circles crosses saltires quarters sunstars crescent
1    Afghanistan        5    1  648         16       10        2    0       3       5   1     1    0    1     1     1      0   green       0       0        0        0        1        0
2        Albania        3    1   29          3        6        6    0       0       3   1     0    0    1     0     1      0     red       0       0        0        0        1        0
3        Algeria        4    1 2388         20        8        2    2       0       3   1     1    0    0     1     0      0   green       0       0        0        0        1        1
4 American-Samoa        6    3    0          0        1        1    0       0       5   1     0    1    1     1     0      1    blue       0       0        0        0        0        0
5        Andorra        3    1    0          0        6        0    3       0       3   1     0    1    1     0     0      0    gold       0       0        0        0        0        0
6         Angola        4    2 1247          7       10        5    0       2       3   1     0    0    1     0     1      0     red       0       0        0        0        1        0
  triangle icon animate text topleft botright
1        0    1       0    0   black    green
2        0    0       1    0     red      red
3        0    0       0    0   green    white
4        1    1       1    0    blue      red
5        0    0       0    0    blue      red
6        0    1       0    0     red    black

| Excellent job!

  |                                                                                                                                                                                          |=====================                                                                                                                                                             |  12%
| You may need to scroll up to see all of the output. Now, let's check out the dimensions of the dataset using dim(flags).

> dim(flags)
[1] 194  30

| Excellent job!

  |                                                                                                                                                                                          |=========================                                                                                                                                                         |  14%
| This tells us that there are 194 rows, or observations, and 30 columns, or variables. Each observation is a country and each variable describes some characteristic of that country or
| its flag. To open a more complete description of the dataset in a separate text file, type viewinfo() when you are back at the prompt (>).

...

  |                                                                                                                                                                                          |============================                                                                                                                                                      |  16%
| As with any dataset, we'd like to know in what format the variables have been stored. In other words, what is the 'class' of each variable? What happens if we do class(flags)? Try it
| out.

> class(flags)
[1] "data.frame"

| You're the best!

  |                                                                                                                                                                                          |================================                                                                                                                                                  |  18%
| That just tells us that the entire dataset is stored as a 'data.frame', which doesn't answer our question. What we really need is to call the class() function on each individual column.
| While we could do this manually (i.e. one column at a time) it's much faster if we can automate the process. Sounds like a loop!

...

  |                                                                                                                                                                                          |====================================                                                                                                                                              |  20%
| The lapply() function takes a list as input, applies a function to each element of the list, then returns a list of the same length as the original one. Since a data frame is really
| just a list of vectors (you can see this with as.list(flags)), we can use lapply() to apply the class() function to each column of the flags dataset. Let's see it in action!

...

  |                                                                                                                                                                                          |=======================================                                                                                                                                           |  22%
| Type cls_list <- lapply(flags, class) to apply the class() function to each column of the flags dataset and store the result in a variable called cls_list. Note that you just supply the
| name of the function you want to apply (i.e. class), without the usual parentheses after it.

> cls_list <- lapply(flags, class)

| You are doing so well!

  |                                                                                                                                                                                          |===========================================                                                                                                                                       |  24%
| Type cls_list to view the result.

> cls_list
$`name`
[1] "factor"

$landmass
[1] "integer"

$zone
[1] "integer"

$area
[1] "integer"

$population
[1] "integer"

$language
[1] "integer"

$religion
[1] "integer"

$bars
[1] "integer"

$stripes
[1] "integer"

$colours
[1] "integer"

$red
[1] "integer"

$green
[1] "integer"

$blue
[1] "integer"

$gold
[1] "integer"

$white
[1] "integer"

$black
[1] "integer"

$orange
[1] "integer"

$mainhue
[1] "factor"

$circles
[1] "integer"

$crosses
[1] "integer"

$saltires
[1] "integer"

$quarters
[1] "integer"

$sunstars
[1] "integer"

$crescent
[1] "integer"

$triangle
[1] "integer"

$icon
[1] "integer"

$animate
[1] "integer"

$text
[1] "integer"

$topleft
[1] "factor"

$botright
[1] "factor"


| Excellent work!

  |                                                                                                                                                                                          |==============================================                                                                                                                                    |  26%
| The 'l' in 'lapply' stands for 'list'. Type class(cls_list) to confirm that lapply() returned a list.

> (cls_list)
$`name`
[1] "factor"

$landmass
[1] "integer"

$zone
[1] "integer"

$area
[1] "integer"

$population
[1] "integer"

$language
[1] "integer"

$religion
[1] "integer"

$bars
[1] "integer"

$stripes
[1] "integer"

$colours
[1] "integer"

$red
[1] "integer"

$green
[1] "integer"

$blue
[1] "integer"

$gold
[1] "integer"

$white
[1] "integer"

$black
[1] "integer"

$orange
[1] "integer"

$mainhue
[1] "factor"

$circles
[1] "integer"

$crosses
[1] "integer"

$saltires
[1] "integer"

$quarters
[1] "integer"

$sunstars
[1] "integer"

$crescent
[1] "integer"

$triangle
[1] "integer"

$icon
[1] "integer"

$animate
[1] "integer"

$text
[1] "integer"

$topleft
[1] "factor"

$botright
[1] "factor"


| You're close...I can feel it! Try it again. Or, type info() for more options.

| Type class(cls_list) to confirm that lapply() returned a list.

> class(cls_list)
[1] "list"

| You are doing so well!

  |                                                                                                                                                                                          |==================================================                                                                                                                                |  28%
| As expected, we got a list of length 30 -- one element for each variable/column. The output would be considerably more compact if we could represent it as a vector instead of a list.

...

  |                                                                                                                                                                                          |=====================================================                                                                                                                             |  30%
| You may remember from a previous lesson that lists are most helpful for storing multiple classes of data. In this case, since every element of the list returned by lapply() is a
| character vector of length one (i.e. "integer" and "vector"), cls_list can be simplified to a character vector. To do this manually, type as.character(cls_list).

> as.character(cls_list)
 [1] "factor"  "integer" "integer" "integer" "integer" "integer" "integer" "integer" "integer" "integer" "integer" "integer" "integer" "integer" "integer" "integer" "integer" "factor" 
[19] "integer" "integer" "integer" "integer" "integer" "integer" "integer" "integer" "integer" "integer" "factor"  "factor" 

| You're the best!

  |                                                                                                                                                                                          |=========================================================                                                                                                                         |  32%
| sapply() allows you to automate this process by calling lapply() behind the scenes, but then attempting to simplify (hence the 's' in 'sapply') the result for you. Use sapply() the same
| way you used lapply() to get the class of each column of the flags dataset and store the result in cls_vect. If you need help, type ?sapply to bring up the documentation.

> sapply(cls_list)
Error in match.fun(FUN) : argument "FUN" is missing, with no default
> cls_list <- sapply (flags,class)

| Almost! Try again. Or, type info() for more options.

| Type cls_vect <- sapply(flags, class) to store the column classes in a character vector called cls_vect.

> cls_vect <-sapply (flags,class)

| You are quite good my friend!

  |                                                                                                                                                                                          |=============================================================                                                                                                                     |  34%
| Use class(cls_vect) to confirm that sapply() simplified the result to a character vector.

> class(cls_vect)
[1] "character"

| That's the answer I was looking for.

  |                                                                                                                                                                                          |================================================================                                                                                                                  |  36%
| In general, if the result is a list where every element is of length one, then sapply() returns a vector. If the result is a list where every element is a vector of the same length (>
| 1), sapply() returns a matrix. If sapply() can't figure things out, then it just returns a list, no different from what lapply() would give you.

...

  |                                                                                                                                                                                          |====================================================================                                                                                                              |  38%
| Let's practice using lapply() and sapply() some more!

...

  |                                                                                                                                                                                          |=======================================================================                                                                                                           |  40%
| Columns 11 through 17 of our dataset are indicator variables, each representing a different color. The value of the indicator variable is 1 if the color is present in a country's flag
| and 0 otherwise.

...

  |                                                                                                                                                                                          |===========================================================================                                                                                                       |  42%
| Therefore, if we want to know the total number of countries (in our dataset) with, for example, the color orange on their flag, we can just add up all of the 1s and 0s in the 'orange'
| column. Try sum(flags$orange) to see this.

> sum(flags$orange)
[1] 26

| You are really on a roll!

  |                                                                                                                                                                                          |==============================================================================                                                                                                    |  44%
| Now we want to repeat this operation for each of the colors recorded in the dataset.

...

  |                                                                                                                                                                                          |==================================================================================                                                                                                |  46%
| First, use flag_colors <- flags[, 11:17] to extract the columns containing the color data and store them in a new data frame called flag_colors. (Note the comma before 11:17. This
| subsetting command tells R that we want all rows, but only columns 11 through 17.)

> flag_colors <- flags [, 11:17]

| Keep working like that and you'll get there!

  |                                                                                                                                                                                          |=====================================================================================                                                                                             |  48%
| Use the head() function to look at the first 6 lines of flag_colors.

> head(flag_colors,1:6)
Error in head.data.frame(flag_colors, 1:6) : length(n) == 1L is not TRUE
> head(flag_colors,1:6)
Error in head.data.frame(flag_colors, 1:6) : length(n) == 1L is not TRUE
> skip()

| Entering the following correct answer for you...

> head(flag_colors)
  red green blue gold white black orange
1   1     1    0    1     1     1      0
2   1     0    0    1     0     1      0
3   1     1    0    0     1     0      0
4   1     0    1    1     1     0      1
5   1     0    1    1     0     0      0
6   1     0    0    1     0     1      0

| Nice work!

  |                                                                                                                                                                                          |=========================================================================================                                                                                         |  50%
| To get a list containing the sum of each column of flag_colors, call the lapply() function with two arguments. The first argument is the object over which we are looping (i.e.
| flag_colors) and the second argument is the name of the function we wish to apply to each column (i.e. sum). Remember that the second argument is just the name of the function with no
| parentheses, etc.

> lapply(flag_colors,sum(column))
Error in match.fun(FUN) : object 'column' not found
> skip()

| Entering the following correct answer for you...

> lapply(flag_colors, sum)
$`red`
[1] 153

$green
[1] 91

$blue
[1] 99

$gold
[1] 91

$white
[1] 146

$black
[1] 52

$orange
[1] 26


| You got it right!

  |                                                                                                                                                                                          |=============================================================================================                                                                                     |  52%
| This tells us that of the 194 flags in our dataset, 153 contain the color red, 91 contain green, 99 contain blue, and so on.

...

  |                                                                                                                                                                                          |================================================================================================                                                                                  |  54%
| The result is a list, since lapply() always returns a list. Each element of this list is of length one, so the result can be simplified to a vector by calling sapply() instead of
| lapply(). Try it now.

> sapply(flag_colors,sum)
   red  green   blue   gold  white  black orange 
   153     91     99     91    146     52     26 

| You are amazing!

  |                                                                                                                                                                                          |====================================================================================================                                                                              |  56%
| Perhaps it's more informative to find the proportion of flags (out of 194) containing each color. Since each column is just a bunch of 1s and 0s, the arithmetic mean of each column will
| give us the proportion of 1s. (If it's not clear why, think of a simpler situation where you have three 1s and two 0s -- (1 + 1 + 1 + 0 + 0)/5 = 3/5 = 0.6).

...

  |                                                                                                                                                                                          |=======================================================================================================                                                                           |  58%
| Use sapply() to apply the mean() function to each column of flag_colors. Remember that the second argument to sapply() should just specify the name of the function (i.e. mean) that you
| want to apply.

> sapply(flag_colors,mean)
      red     green      blue      gold     white     black    orange 
0.7886598 0.4690722 0.5103093 0.4690722 0.7525773 0.2680412 0.1340206 

| Excellent work!

  |                                                                                                                                                                                          |===========================================================================================================                                                                       |  60%
| In the examples we've looked at so far, sapply() has been able to simplify the result to vector. That's because each element of the list returned by lapply() was a vector of length one.
| Recall that sapply() instead returns a matrix when each element of the list returned by lapply() is a vector of the same length (> 1).

...

  |                                                                                                                                                                                          |==============================================================================================================                                                                    |  62%
| To illustrate this, let's extract columns 19 through 23 from the flags dataset and store the result in a new data frame called flag_shapes. flag_shapes <- flags[, 19:23] will do it.

> flag_shapes <-flags[,19:23]

| Your dedication is inspiring!

  |                                                                                                                                                                                          |==================================================================================================================                                                                |  64%
| Each of these columns (i.e. variables) represents the number of times a particular shape or design appears on a country's flag. We are interested in the minimum and maximum number of
| times each shape or design appears.

...

  |                                                                                                                                                                                          |=====================================================================================================================                                                             |  66%
| The range() function returns the minimum and maximum of its first argument, which should be a numeric vector. Use lapply() to apply the range function to each column of flag_shapes.
| Don't worry about storing the result in a new variable. By now, we know that lapply() always returns a list.

> lappy(flag_shapes,range)
Error in lappy(flag_shapes, range) : could not find function "lappy"
> lapply(flag_shapes,range)
$`circles`
[1] 0 4

$crosses
[1] 0 2

$saltires
[1] 0 1

$quarters
[1] 0 4

$sunstars
[1]  0 50


| That's correct!

  |                                                                                                                                                                                          |=========================================================================================================================                                                         |  68%
| Do the same operation, but using sapply() and store the result in a variable called shape_mat.

> shape_mat<- sapply(flag_shapes,range)

| Keep working like that and you'll get there!

  |                                                                                                                                                                                          |=============================================================================================================================                                                     |  70%
| View the contents of shape_mat.

> shape_mat
     circles crosses saltires quarters sunstars
[1,]       0       0        0        0        0
[2,]       4       2        1        4       50

| Nice work!

  |                                                                                                                                                                                          |================================================================================================================================                                                  |  72%
| Each column of shape_mat gives the minimum (row 1) and maximum (row 2) number of times its respective shape appears in different flags.

...

  |                                                                                                                                                                                          |====================================================================================================================================                                              |  74%
| Use the class() function to confirm that shape_mat is a matrix.

> class(shape_mat)
[1] "matrix"

| You're the best!

  |                                                                                                                                                                                          |=======================================================================================================================================                                           |  76%
| As we've seen, sapply() always attempts to simplify the result given by lapply(). It has been successful in doing so for each of the examples we've looked at so far. Let's look at an
| example where sapply() can't figure out how to simplify the result and thus returns a list, no different from lapply().

...

  |                                                                                                                                                                                          |===========================================================================================================================================                                       |  78%
| When given a vector, the unique() function returns a vector with all duplicate elements removed. In other words, unique() returns a vector of only the 'unique' elements. To see how it
| works, try unique(c(3, 4, 5, 5, 5, 6, 6)).

> unique(c(3,4,5,5,5,6,6))
[1] 3 4 5 6

| You got it!

  |                                                                                                                                                                                          |==============================================================================================================================================                                    |  80%
| We want to know the unique values for each variable in the flags dataset. To accomplish this, use lapply() to apply the unique() function to each column in the flags dataset, storing
| the result in a variable called unique_vals.

> unique_vals <- lappy(flags,unique)
Error in lappy(flags, unique) : could not find function "lappy"
> unique_vals <- lapply(flags,unique)

| That's the answer I was looking for.

  |                                                                                                                                                                                          |==================================================================================================================================================                                |  82%
| Print the value of unique_vals to the console.

> print(unique_vals)
$`name`
  [1] Afghanistan              Albania                  Algeria                  American-Samoa           Andorra                  Angola                   Anguilla                
  [8] Antigua-Barbuda          Argentina                Argentine                Australia                Austria                  Bahamas                  Bahrain                 
 [15] Bangladesh               Barbados                 Belgium                  Belize                   Benin                    Bermuda                  Bhutan                  
 [22] Bolivia                  Botswana                 Brazil                   British-Virgin-Isles     Brunei                   Bulgaria                 Burkina                 
 [29] Burma                    Burundi                  Cameroon                 Canada                   Cape-Verde-Islands       Cayman-Islands           Central-African-Republic
 [36] Chad                     Chile                    China                    Colombia                 Comorro-Islands          Congo                    Cook-Islands            
 [43] Costa-Rica               Cuba                     Cyprus                   Czechoslovakia           Denmark                  Djibouti                 Dominica                
 [50] Dominican-Republic       Ecuador                  Egypt                    El-Salvador              Equatorial-Guinea        Ethiopia                 Faeroes                 
 [57] Falklands-Malvinas       Fiji                     Finland                  France                   French-Guiana            French-Polynesia         Gabon                   
 [64] Gambia                   Germany-DDR              Germany-FRG              Ghana                    Gibraltar                Greece                   Greenland               
 [71] Grenada                  Guam                     Guatemala                Guinea                   Guinea-Bissau            Guyana                   Haiti                   
 [78] Honduras                 Hong-Kong                Hungary                  Iceland                  India                    Indonesia                Iran                    
 [85] Iraq                     Ireland                  Israel                   Italy                    Ivory-Coast              Jamaica                  Japan                   
 [92] Jordan                   Kampuchea                Kenya                    Kiribati                 Kuwait                   Laos                     Lebanon                 
 [99] Lesotho                  Liberia                  Libya                    Liechtenstein            Luxembourg               Malagasy                 Malawi                  
[106] Malaysia                 Maldive-Islands          Mali                     Malta                    Marianas                 Mauritania               Mauritius               
[113] Mexico                   Micronesia               Monaco                   Mongolia                 Montserrat               Morocco                  Mozambique              
[120] Nauru                    Nepal                    Netherlands              Netherlands-Antilles     New-Zealand              Nicaragua                Niger                   
[127] Nigeria                  Niue                     North-Korea              North-Yemen              Norway                   Oman                     Pakistan                
[134] Panama                   Papua-New-Guinea         Parguay                  Peru                     Philippines              Poland                   Portugal                
[141] Puerto-Rico              Qatar                    Romania                  Rwanda                   San-Marino               Sao-Tome                 Saudi-Arabia            
[148] Senegal                  Seychelles               Sierra-Leone             Singapore                Soloman-Islands          Somalia                  South-Africa            
[155] South-Korea              South-Yemen              Spain                    Sri-Lanka                St-Helena                St-Kitts-Nevis           St-Lucia                
[162] St-Vincent               Sudan                    Surinam                  Swaziland                Sweden                   Switzerland              Syria                   
[169] Taiwan                   Tanzania                 Thailand                 Togo                     Tonga                    Trinidad-Tobago          Tunisia                 
[176] Turkey                   Turks-Cocos-Islands      Tuvalu                   UAE                      Uganda                   UK                       Uruguay                 
[183] US-Virgin-Isles          USA                      USSR                     Vanuatu                  Vatican-City             Venezuela                Vietnam                 
[190] Western-Samoa            Yugoslavia               Zaire                    Zambia                   Zimbabwe                
194 Levels: Afghanistan Albania Algeria American-Samoa Andorra Angola Anguilla Antigua-Barbuda Argentina Argentine Australia Austria Bahamas Bahrain Bangladesh Barbados Belgium ... Zimbabwe

$landmass
[1] 5 3 4 6 1 2

$zone
[1] 1 3 2 4

$area
  [1]   648    29  2388     0  1247  2777  7690    84    19     1   143    31    23   113    47  1099   600  8512     6   111   274   678    28   474  9976     4   623  1284   757  9561
 [31]  1139     2   342    51   115     9   128    43    22    49   284  1001    21  1222    12    18   337   547    91   268    10   108   249   239   132  2176   109   246    36   215
 [61]   112    93   103  3268  1904  1648   435    70   301   323    11   372    98   181   583   236    30  1760     3   587   118   333  1240  1031  1973  1566   447   783   140    41
 [91]  1267   925   121   195   324   212   804    76   463   407  1285   300   313    92   237    26  2150   196    72   637  1221    99   288   505    66  2506    63    17   450   185
[121]   945   514    57     5   164   781   245   178  9363 22402    15   912   256   905   753   391

$population
 [1]   16    3   20    0    7   28   15    8   90   10    1    6  119    9   35    4   24    2   11 1008    5   47   31   54   17   61   14  684  157   39   57  118   13   77   12   56
[37]   18   84   48   36   22   29   38   49   45  231  274   60

$language
 [1] 10  6  8  1  2  4  3  5  7  9

$religion
[1] 2 6 1 0 5 3 4 7

$bars
[1] 0 2 3 1 5

$stripes
 [1]  3  0  2  1  5  9 11 14  4  6 13  7

$colours
[1] 5 3 2 8 6 4 7 1

$red
[1] 1 0

$green
[1] 1 0

$blue
[1] 0 1

$gold
[1] 1 0

$white
[1] 1 0

$black
[1] 1 0

$orange
[1] 0 1

$mainhue
[1] green  red    blue   gold   white  orange black  brown 
Levels: black blue brown gold green orange red white

$circles
[1] 0 1 4 2

$crosses
[1] 0 1 2

$saltires
[1] 0 1

$quarters
[1] 0 1 4

$sunstars
 [1]  1  0  6 22 14  3  4  5 15 10  7  2  9 50

$crescent
[1] 0 1

$triangle
[1] 0 1

$icon
[1] 1 0

$animate
[1] 0 1

$text
[1] 0 1

$topleft
[1] black  red    green  blue   white  orange gold  
Levels: black blue gold green orange red white

$botright
[1] green  red    white  black  blue   gold   orange brown 
Levels: black blue brown gold green orange red white


| You got it right!

  |                                                                                                                                                                                          |======================================================================================================================================================                            |  84%
| Since unique_vals is a list, you can use what you've learned to determine the length of each element of unique_vals (i.e. the number of unique values for each variable). Simplify the
| result, if possible. Hint: Apply the length() function to each element of unique_vals.

> length(unique_vals)
[1] 30

| Not exactly. Give it another go. Or, type info() for more options.

| Apply the length() function to each element of the unique_vals list using sapply(). Remember, no parentheses after the name of the function you are applying (i.e. length).

> sapply(unique_vals,length)
      name   landmass       zone       area population   language   religion       bars    stripes    colours        red      green       blue       gold      white      black     orange 
       194          6          4        136         48         10          8          5         12          8          2          2          2          2          2          2          2 
   mainhue    circles    crosses   saltires   quarters   sunstars   crescent   triangle       icon    animate       text    topleft   botright 
         8          4          3          2          3         14          2          2          2          2          2          7          8 

| Perseverance, that's the answer.

  |                                                                                                                                                                                          |=========================================================================================================================================================                         |  86%
| The fact that the elements of the unique_vals list are all vectors of *different* length poses a problem for sapply(), since there's no obvious way of simplifying the result.

...

  |                                                                                                                                                                                          |=============================================================================================================================================================                     |  88%
| Use sapply() to apply the unique() function to each column of the flags dataset to see that you get the same unsimplified list that you got from lapply().

> sapply(flags,unique)
$`name`
  [1] Afghanistan              Albania                  Algeria                  American-Samoa           Andorra                  Angola                   Anguilla                
  [8] Antigua-Barbuda          Argentina                Argentine                Australia                Austria                  Bahamas                  Bahrain                 
 [15] Bangladesh               Barbados                 Belgium                  Belize                   Benin                    Bermuda                  Bhutan                  
 [22] Bolivia                  Botswana                 Brazil                   British-Virgin-Isles     Brunei                   Bulgaria                 Burkina                 
 [29] Burma                    Burundi                  Cameroon                 Canada                   Cape-Verde-Islands       Cayman-Islands           Central-African-Republic
 [36] Chad                     Chile                    China                    Colombia                 Comorro-Islands          Congo                    Cook-Islands            
 [43] Costa-Rica               Cuba                     Cyprus                   Czechoslovakia           Denmark                  Djibouti                 Dominica                
 [50] Dominican-Republic       Ecuador                  Egypt                    El-Salvador              Equatorial-Guinea        Ethiopia                 Faeroes                 
 [57] Falklands-Malvinas       Fiji                     Finland                  France                   French-Guiana            French-Polynesia         Gabon                   
 [64] Gambia                   Germany-DDR              Germany-FRG              Ghana                    Gibraltar                Greece                   Greenland               
 [71] Grenada                  Guam                     Guatemala                Guinea                   Guinea-Bissau            Guyana                   Haiti                   
 [78] Honduras                 Hong-Kong                Hungary                  Iceland                  India                    Indonesia                Iran                    
 [85] Iraq                     Ireland                  Israel                   Italy                    Ivory-Coast              Jamaica                  Japan                   
 [92] Jordan                   Kampuchea                Kenya                    Kiribati                 Kuwait                   Laos                     Lebanon                 
 [99] Lesotho                  Liberia                  Libya                    Liechtenstein            Luxembourg               Malagasy                 Malawi                  
[106] Malaysia                 Maldive-Islands          Mali                     Malta                    Marianas                 Mauritania               Mauritius               
[113] Mexico                   Micronesia               Monaco                   Mongolia                 Montserrat               Morocco                  Mozambique              
[120] Nauru                    Nepal                    Netherlands              Netherlands-Antilles     New-Zealand              Nicaragua                Niger                   
[127] Nigeria                  Niue                     North-Korea              North-Yemen              Norway                   Oman                     Pakistan                
[134] Panama                   Papua-New-Guinea         Parguay                  Peru                     Philippines              Poland                   Portugal                
[141] Puerto-Rico              Qatar                    Romania                  Rwanda                   San-Marino               Sao-Tome                 Saudi-Arabia            
[148] Senegal                  Seychelles               Sierra-Leone             Singapore                Soloman-Islands          Somalia                  South-Africa            
[155] South-Korea              South-Yemen              Spain                    Sri-Lanka                St-Helena                St-Kitts-Nevis           St-Lucia                
[162] St-Vincent               Sudan                    Surinam                  Swaziland                Sweden                   Switzerland              Syria                   
[169] Taiwan                   Tanzania                 Thailand                 Togo                     Tonga                    Trinidad-Tobago          Tunisia                 
[176] Turkey                   Turks-Cocos-Islands      Tuvalu                   UAE                      Uganda                   UK                       Uruguay                 
[183] US-Virgin-Isles          USA                      USSR                     Vanuatu                  Vatican-City             Venezuela                Vietnam                 
[190] Western-Samoa            Yugoslavia               Zaire                    Zambia                   Zimbabwe                
194 Levels: Afghanistan Albania Algeria American-Samoa Andorra Angola Anguilla Antigua-Barbuda Argentina Argentine Australia Austria Bahamas Bahrain Bangladesh Barbados Belgium ... Zimbabwe

$landmass
[1] 5 3 4 6 1 2

$zone
[1] 1 3 2 4

$area
  [1]   648    29  2388     0  1247  2777  7690    84    19     1   143    31    23   113    47  1099   600  8512     6   111   274   678    28   474  9976     4   623  1284   757  9561
 [31]  1139     2   342    51   115     9   128    43    22    49   284  1001    21  1222    12    18   337   547    91   268    10   108   249   239   132  2176   109   246    36   215
 [61]   112    93   103  3268  1904  1648   435    70   301   323    11   372    98   181   583   236    30  1760     3   587   118   333  1240  1031  1973  1566   447   783   140    41
 [91]  1267   925   121   195   324   212   804    76   463   407  1285   300   313    92   237    26  2150   196    72   637  1221    99   288   505    66  2506    63    17   450   185
[121]   945   514    57     5   164   781   245   178  9363 22402    15   912   256   905   753   391

$population
 [1]   16    3   20    0    7   28   15    8   90   10    1    6  119    9   35    4   24    2   11 1008    5   47   31   54   17   61   14  684  157   39   57  118   13   77   12   56
[37]   18   84   48   36   22   29   38   49   45  231  274   60

$language
 [1] 10  6  8  1  2  4  3  5  7  9

$religion
[1] 2 6 1 0 5 3 4 7

$bars
[1] 0 2 3 1 5

$stripes
 [1]  3  0  2  1  5  9 11 14  4  6 13  7

$colours
[1] 5 3 2 8 6 4 7 1

$red
[1] 1 0

$green
[1] 1 0

$blue
[1] 0 1

$gold
[1] 1 0

$white
[1] 1 0

$black
[1] 1 0

$orange
[1] 0 1

$mainhue
[1] green  red    blue   gold   white  orange black  brown 
Levels: black blue brown gold green orange red white

$circles
[1] 0 1 4 2

$crosses
[1] 0 1 2

$saltires
[1] 0 1

$quarters
[1] 0 1 4

$sunstars
 [1]  1  0  6 22 14  3  4  5 15 10  7  2  9 50

$crescent
[1] 0 1

$triangle
[1] 0 1

$icon
[1] 1 0

$animate
[1] 0 1

$text
[1] 0 1

$topleft
[1] black  red    green  blue   white  orange gold  
Levels: black blue gold green orange red white

$botright
[1] green  red    white  black  blue   gold   orange brown 
Levels: black blue brown gold green orange red white


| That's correct!

  |                                                                                                                                                                                          |================================================================================================================================================================                  |  90%
| Occasionally, you may need to apply a function that is not yet defined, thus requiring you to write your own. Writing functions in R is beyond the scope of this lesson, but let's look
| at a quick example of how you might do so in the context of loop functions.

...

  |                                                                                                                                                                                          |====================================================================================================================================================================              |  92%
| Pretend you are interested in only the second item from each element of the unique_vals list that you just created. Since each element of the unique_vals list is a vector and we're not
| aware of any built-in function in R that returns the second element of a vector, we will construct our own function.

...

  |                                                                                                                                                                                          |=======================================================================================================================================================================           |  94%
| lapply(unique_vals, function(elem) elem[2]) will return a list containing the second item from each element of the unique_vals list. Note that our function takes one argument, elem,
| which is just a 'dummy variable' that takes on the value of each element of unique_vals, in turn.

> skip()

| Entering the following correct answer for you...

> lapply(unique_vals, function(elem) elem[2])
$`name`
[1] Albania
194 Levels: Afghanistan Albania Algeria American-Samoa Andorra Angola Anguilla Antigua-Barbuda Argentina Argentine Australia Austria Bahamas Bahrain Bangladesh Barbados Belgium ... Zimbabwe

$landmass
[1] 3

$zone
[1] 3

$area
[1] 29

$population
[1] 3

$language
[1] 6

$religion
[1] 6

$bars
[1] 2

$stripes
[1] 0

$colours
[1] 3

$red
[1] 0

$green
[1] 0

$blue
[1] 1

$gold
[1] 0

$white
[1] 0

$black
[1] 0

$orange
[1] 1

$mainhue
[1] red
Levels: black blue brown gold green orange red white

$circles
[1] 1

$crosses
[1] 1

$saltires
[1] 1

$quarters
[1] 1

$sunstars
[1] 0

$crescent
[1] 1

$triangle
[1] 1

$icon
[1] 0

$animate
[1] 1

$text
[1] 1

$topleft
[1] red
Levels: black blue gold green orange red white

$botright
[1] red
Levels: black blue brown gold green orange red white


| You got it!

  |                                                                                                                                                                                          |===========================================================================================================================================================================       |  96%
| The only difference between previous examples and this one is that we are defining and using our own function right in the call to lapply(). Our function has no name and disappears as
| soon as lapply() is done using it. So-called 'anonymous functions' can be very useful when one of R's built-in functions isn't an option.

...

  |                                                                                                                                                                                          |==============================================================================================================================================================================    |  98%
| In this lesson, you learned how to use the powerful lapply() and sapply() functions to apply an operation over the elements of a list. In the next lesson, we'll take a look at some
| close relatives of lapply() and sapply().

...

  |                                                                                                                                                                                          |==================================================================================================================================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: Yes
2: No

Selection: 2

| Keep up the great work!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply         11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times           15: Base Graphics             

Selection: 11

  |                                                                                                                                                                                          |                                                                                                                                                                                  |   0%

| In the last lesson, you learned about the two most fundamental members of R's *apply family of functions: lapply() and sapply(). Both take a list as input, apply a function to each
| element of the list, then combine and return the result. lapply() always returns a list, whereas sapply() attempts to simplify the result.

...

  |                                                                                                                                                                                          |=======                                                                                                                                                                           |   4%
| In this lesson, you'll learn how to use vapply() and tapply(), each of which serves a very specific purpose within the Split-Apply-Combine methodology. For consistency, we'll use the
| same dataset we used in the 'lapply and sapply' lesson.

...

  |                                                                                                                                                                                          |==============                                                                                                                                                                    |   8%
| The Flags dataset from the UCI Machine Learning Repository contains details of various nations and their flags. More information may be found here:
| http://archive.ics.uci.edu/ml/datasets/Flags

...

  |                                                                                                                                                                                          |=====================                                                                                                                                                             |  12%
| I've stored the data in a variable called flags. If it's been a while since you completed the 'lapply and sapply' lesson, you may want to reacquaint yourself with the data by using
| functions like dim(), head(), str(), and summary() when you return to the prompt (>). You can also type viewinfo() at the prompt to bring up some documentation for the dataset. Let's
| get started!

...

  |                                                                                                                                                                                          |============================                                                                                                                                                      |  16%
| As you saw in the last lesson, the unique() function returns a vector of the unique values contained in the object passed to it. Therefore, sapply(flags, unique) returns a list
| containing one vector of unique values for each column of the flags dataset. Try it again now.

> sapply(flags,unique)
$`name`
  [1] Afghanistan              Albania                  Algeria                  American-Samoa           Andorra                  Angola                   Anguilla                
  [8] Antigua-Barbuda          Argentina                Argentine                Australia                Austria                  Bahamas                  Bahrain                 
 [15] Bangladesh               Barbados                 Belgium                  Belize                   Benin                    Bermuda                  Bhutan                  
 [22] Bolivia                  Botswana                 Brazil                   British-Virgin-Isles     Brunei                   Bulgaria                 Burkina                 
 [29] Burma                    Burundi                  Cameroon                 Canada                   Cape-Verde-Islands       Cayman-Islands           Central-African-Republic
 [36] Chad                     Chile                    China                    Colombia                 Comorro-Islands          Congo                    Cook-Islands            
 [43] Costa-Rica               Cuba                     Cyprus                   Czechoslovakia           Denmark                  Djibouti                 Dominica                
 [50] Dominican-Republic       Ecuador                  Egypt                    El-Salvador              Equatorial-Guinea        Ethiopia                 Faeroes                 
 [57] Falklands-Malvinas       Fiji                     Finland                  France                   French-Guiana            French-Polynesia         Gabon                   
 [64] Gambia                   Germany-DDR              Germany-FRG              Ghana                    Gibraltar                Greece                   Greenland               
 [71] Grenada                  Guam                     Guatemala                Guinea                   Guinea-Bissau            Guyana                   Haiti                   
 [78] Honduras                 Hong-Kong                Hungary                  Iceland                  India                    Indonesia                Iran                    
 [85] Iraq                     Ireland                  Israel                   Italy                    Ivory-Coast              Jamaica                  Japan                   
 [92] Jordan                   Kampuchea                Kenya                    Kiribati                 Kuwait                   Laos                     Lebanon                 
 [99] Lesotho                  Liberia                  Libya                    Liechtenstein            Luxembourg               Malagasy                 Malawi                  
[106] Malaysia                 Maldive-Islands          Mali                     Malta                    Marianas                 Mauritania               Mauritius               
[113] Mexico                   Micronesia               Monaco                   Mongolia                 Montserrat               Morocco                  Mozambique              
[120] Nauru                    Nepal                    Netherlands              Netherlands-Antilles     New-Zealand              Nicaragua                Niger                   
[127] Nigeria                  Niue                     North-Korea              North-Yemen              Norway                   Oman                     Pakistan                
[134] Panama                   Papua-New-Guinea         Parguay                  Peru                     Philippines              Poland                   Portugal                
[141] Puerto-Rico              Qatar                    Romania                  Rwanda                   San-Marino               Sao-Tome                 Saudi-Arabia            
[148] Senegal                  Seychelles               Sierra-Leone             Singapore                Soloman-Islands          Somalia                  South-Africa            
[155] South-Korea              South-Yemen              Spain                    Sri-Lanka                St-Helena                St-Kitts-Nevis           St-Lucia                
[162] St-Vincent               Sudan                    Surinam                  Swaziland                Sweden                   Switzerland              Syria                   
[169] Taiwan                   Tanzania                 Thailand                 Togo                     Tonga                    Trinidad-Tobago          Tunisia                 
[176] Turkey                   Turks-Cocos-Islands      Tuvalu                   UAE                      Uganda                   UK                       Uruguay                 
[183] US-Virgin-Isles          USA                      USSR                     Vanuatu                  Vatican-City             Venezuela                Vietnam                 
[190] Western-Samoa            Yugoslavia               Zaire                    Zambia                   Zimbabwe                
194 Levels: Afghanistan Albania Algeria American-Samoa Andorra Angola Anguilla Antigua-Barbuda Argentina Argentine Australia Austria Bahamas Bahrain Bangladesh Barbados Belgium ... Zimbabwe

$landmass
[1] 5 3 4 6 1 2

$zone
[1] 1 3 2 4

$area
  [1]   648    29  2388     0  1247  2777  7690    84    19     1   143    31    23   113    47  1099   600  8512     6   111   274   678    28   474  9976     4   623  1284   757  9561
 [31]  1139     2   342    51   115     9   128    43    22    49   284  1001    21  1222    12    18   337   547    91   268    10   108   249   239   132  2176   109   246    36   215
 [61]   112    93   103  3268  1904  1648   435    70   301   323    11   372    98   181   583   236    30  1760     3   587   118   333  1240  1031  1973  1566   447   783   140    41
 [91]  1267   925   121   195   324   212   804    76   463   407  1285   300   313    92   237    26  2150   196    72   637  1221    99   288   505    66  2506    63    17   450   185
[121]   945   514    57     5   164   781   245   178  9363 22402    15   912   256   905   753   391

$population
 [1]   16    3   20    0    7   28   15    8   90   10    1    6  119    9   35    4   24    2   11 1008    5   47   31   54   17   61   14  684  157   39   57  118   13   77   12   56
[37]   18   84   48   36   22   29   38   49   45  231  274   60

$language
 [1] 10  6  8  1  2  4  3  5  7  9

$religion
[1] 2 6 1 0 5 3 4 7

$bars
[1] 0 2 3 1 5

$stripes
 [1]  3  0  2  1  5  9 11 14  4  6 13  7

$colours
[1] 5 3 2 8 6 4 7 1

$red
[1] 1 0

$green
[1] 1 0

$blue
[1] 0 1

$gold
[1] 1 0

$white
[1] 1 0

$black
[1] 1 0

$orange
[1] 0 1

$mainhue
[1] green  red    blue   gold   white  orange black  brown 
Levels: black blue brown gold green orange red white

$circles
[1] 0 1 4 2

$crosses
[1] 0 1 2

$saltires
[1] 0 1

$quarters
[1] 0 1 4

$sunstars
 [1]  1  0  6 22 14  3  4  5 15 10  7  2  9 50

$crescent
[1] 0 1

$triangle
[1] 0 1

$icon
[1] 1 0

$animate
[1] 0 1

$text
[1] 0 1

$topleft
[1] black  red    green  blue   white  orange gold  
Levels: black blue gold green orange red white

$botright
[1] green  red    white  black  blue   gold   orange brown 
Levels: black blue brown gold green orange red white


| That's a job well done!

  |                                                                                                                                                                                          |====================================                                                                                                                                              |  20%
| What if you had forgotten how unique() works and mistakenly thought it returns the *number* of unique values contained in the object passed to it? Then you might have incorrectly
| expected sapply(flags, unique) to return a numeric vector, since each element of the list returned would contain a single number and sapply() could then simplify the result to a vector.

...

  |                                                                                                                                                                                          |===========================================                                                                                                                                       |  24%
| When working interactively (at the prompt), this is not much of a problem, since you see the result immediately and will quickly recognize your mistake. However, when working
| non-interactively (e.g. writing your own functions), a misunderstanding may go undetected and cause incorrect results later on. Therefore, you may wish to be more careful and that's
| where vapply() is useful.

...

  |                                                                                                                                                                                          |==================================================                                                                                                                                |  28%
| Whereas sapply() tries to 'guess' the correct format of the result, vapply() allows you to specify it explicitly. If the result doesn't match the format you specify, vapply() will throw
| an error, causing the operation to stop. This can prevent significant problems in your code that might be caused by getting unexpected return values from sapply().

...

  |                                                                                                                                                                                          |=========================================================                                                                                                                         |  32%
| Try vapply(flags, unique, numeric(1)), which says that you expect each element of the result to be a numeric vector of length 1. Since this is NOT actually the case, YOU WILL GET AN
| ERROR. Once you get the error, type ok() to continue to the next question.

> vapply(flags,unique,numeric(1))
Error in vapply(flags, unique, numeric(1)) : values must be length 1,
 but FUN(X[[1]]) result is length 194
> ok()

| You are quite good my friend!

  |                                                                                                                                                                                          |================================================================                                                                                                                  |  36%
| Recall from the previous lesson that sapply(flags, class) will return a character vector containing the class of each column in the dataset. Try that again now to see the result.

> sapply(flags,class)
      name   landmass       zone       area population   language   religion       bars    stripes    colours        red      green       blue       gold      white      black     orange 
  "factor"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer" 
   mainhue    circles    crosses   saltires   quarters   sunstars   crescent   triangle       icon    animate       text    topleft   botright 
  "factor"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"   "factor"   "factor" 

| Keep up the great work!

  |                                                                                                                                                                                          |=======================================================================                                                                                                           |  40%
| If we wish to be explicit about the format of the result we expect, we can use vapply(flags, class, character(1)). The 'character(1)' argument tells R that we expect the class function
| to return a character vector of length 1 when applied to EACH column of the flags dataset. Try it now.

> vapply(flags,class,character(1))
      name   landmass       zone       area population   language   religion       bars    stripes    colours        red      green       blue       gold      white      black     orange 
  "factor"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer" 
   mainhue    circles    crosses   saltires   quarters   sunstars   crescent   triangle       icon    animate       text    topleft   botright 
  "factor"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"  "integer"   "factor"   "factor" 

| Keep working like that and you'll get there!

  |                                                                                                                                                                                          |==============================================================================                                                                                                    |  44%
| Note that since our expectation was correct (i.e. character(1)), the vapply() result is identical to the sapply() result -- a character vector of column classes.

...

  |                                                                                                                                                                                          |=====================================================================================                                                                                             |  48%
| You might think of vapply() as being 'safer' than sapply(), since it requires you to specify the format of the output in advance, instead of just allowing R to 'guess' what you wanted.
| In addition, vapply() may perform faster than sapply() for large datasets. However, when doing data analysis interactively (at the prompt), sapply() saves you some typing and will often
| be good enough.

...

  |                                                                                                                                                                                          |=============================================================================================                                                                                     |  52%
| As a data analyst, you'll often wish to split your data up into groups based on the value of some variable, then apply a function to the members of each group. The next function we'll
| look at, tapply(), does exactly that.

...

  |                                                                                                                                                                                          |====================================================================================================                                                                              |  56%
| Use ?tapply to pull up the documentation.

> ?tapply

| You got it right!

  |                                                                                                                                                                                          |===========================================================================================================                                                                       |  60%
| The 'landmass' variable in our dataset takes on integer values between 1 and 6, each of which represents a different part of the world. Use table(flags$landmass) to see how many
| flags/countries fall into each group.

> table(flags$landmass)

 1  2  3  4  5  6 
31 17 35 52 39 20 

| Keep working like that and you'll get there!

  |                                                                                                                                                                                          |==================================================================================================================                                                                |  64%
| The 'animate' variable in our dataset takes the value 1 if a country's flag contains an animate image (e.g. an eagle, a tree, a human hand) and 0 otherwise. Use table(flags$animate) to
| see how many flags contain an animate image.

> table(flags$animate)

  0   1 
155  39 

| That's correct!

  |                                                                                                                                                                                          |=========================================================================================================================                                                         |  68%
| This tells us that 39 flags contain an animate object (animate = 1) and 155 do not (animate = 0).

...

  |                                                                                                                                                                                          |================================================================================================================================                                                  |  72%
| If you take the arithmetic mean of a bunch of 0s and 1s, you get the proportion of 1s. Use tapply(flags$animate, flags$landmass, mean) to apply the mean function to the 'animate'
| variable separately for each of the six landmass groups, thus giving us the proportion of flags containing an animate image WITHIN each landmass group.

> tapply(flags$animate, flags$landmass, mean)
        1         2         3         4         5         6 
0.4193548 0.1764706 0.1142857 0.1346154 0.1538462 0.3000000 

| All that practice is paying off!

  |                                                                                                                                                                                          |=======================================================================================================================================                                           |  76%
| The first landmass group (landmass = 1) corresponds to North America and contains the highest proportion of flags with an animate image (0.4194).

...

  |                                                                                                                                                                                          |==============================================================================================================================================                                    |  80%
| Similarly, we can look at a summary of population values (in round millions) for countries with and without the color red on their flag with tapply(flags$population, flags$red,
| summary).

> tapply(flags$population, flags$red,summary)
$`0`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    3.00   27.63    9.00  684.00 

$`1`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    0.0     0.0     4.0    22.1    15.0  1008.0 


| That's a job well done!

  |                                                                                                                                                                                          |======================================================================================================================================================                            |  84%
| What is the median population (in millions) for countries *without* the color red on their flag?

1: 3.0
2: 27.6
3: 4.0
4: 9.0
5: 0.0
6: 22.1

Selection: 1

| Keep working like that and you'll get there!

  |                                                                                                                                                                                          |=============================================================================================================================================================                     |  88%
| Lastly, use the same approach to look at a summary of population values for each of the six landmasses.

> tapply(flags$population, flags$landmasses, summary)
Error in tapply(flags$population, flags$landmasses, summary) : 
  arguments must have same length
> tapply(flags$animate, flags$landmasses, summary)
Error in tapply(flags$animate, flags$landmasses, summary) : 
  arguments must have same length
> skip()

| Entering the following correct answer for you...

> tapply(flags$population, flags$landmass, summary)
$`1`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    0.00   12.29    4.50  231.00 

$`2`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    1.00    6.00   15.71   15.00  119.00 

$`3`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    8.00   13.86   16.00   61.00 

$`4`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  0.000   1.000   5.000   8.788   9.750  56.000 

$`5`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    2.00   10.00   69.18   39.00 1008.00 

$`6`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    0.00   11.30    1.25  157.00 


| Perseverance, that's the answer.

  |                                                                                                                                                                                          |====================================================================================================================================================================              |  92%
| What is the maximum population (in millions) for the fourth landmass group (Africa)?

1: 119.0
2: 1010.0
3: 56.00
4: 157.00
5: 5.00

Selection: 3

| You got it right!

  |                                                                                                                                                                                          |===========================================================================================================================================================================       |  96%
| In this lesson, you learned how to use vapply() as a safer alternative to sapply(), which is most helpful when writing your own functions. You also learned how to use tapply() to split
| your data into groups based on the value of some variable, then apply a function to each group. These functions will come in handy on your quest to become a better data analyst.

...

  |                                                                                                                                                                                          |==================================================================================================================================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: No
2: Yes

Selection: 1

| That's a job well done!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 
